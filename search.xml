<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Android 面试之编程算法题]]></title>
      <url>http://eddy.wiki/interview-code.html</url>
      <content type="text"><![CDATA[本文出自 Eddy Wiki ，转载请注明出处：http://eddy.wiki/interview-code.html 本文收集整理了 Android 面试中会遇到的编程算法题。 推荐几个做编程题目的网站： 牛客网 LeetCode LintCode 下列题目来源： Mr-YangCheng/ForAndroidInterview — 该处题目应该也是来源于剑指 Offer，不过每题都有详细思路和解法，值得一看。 牛客网-剑指 Offer 二维数组中查找题目： 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 分析： 根据题意画了个简单的图，首先我们要确定查找开始的位置，因为它是二维的数组，它的下标变化是两个方向的，根据四个边界点来分析。 a b ​ c d Ａ：向下 增 ，向右 增 Ｂ：向左 减 ，向下 增 Ｃ：向上 减 ，向右 增 Ｄ：向左 减 ，向上 减 可以看出从B 或Ｃ点开始查找刚好可以构建一个二叉查找树。 二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。 先确定二维数组的行数和列数，把 查找值 与 二叉查找树的根节点（Ｂ或者 Ｃ）开始比较，如果相等返回true，小于查找左子树，大于就查找右子树。如果遍历超过数组边界，就返回 false。 以C为根节点查找 1234567891011121314151617181920public class Solution &#123; public boolean Find(int [][] array,int target) &#123; int i = array.length -1; int m = array[0].length -1; int j = 0; while(i&gt;=0 &amp;&amp; j&lt;=m)&#123; if(target == array[i][j])&#123; return true; &#125;else if(target &gt;array[i][j])&#123; j++; &#125;else&#123; i--; &#125; &#125; return false; &#125;&#125; 以B为根节点查找 1234567891011121314151617181920public class Solution &#123; public boolean Find(int [][] array,int target) &#123; int i = array.length -1; int j = array[0].length -1; int n = 0; while(j&gt;=0 &amp;&amp; n&lt;=i)&#123; if(target == array[n][j])&#123; return true; &#125;else if(target &gt;array[n][j])&#123; n++; &#125;else&#123; j--; &#125; &#125; return false; &#125;&#125; 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。题目分析 解法一 运行时间：29m 占用内存：629k 1234567891011121314public int NumberOf1(int n) &#123; String s=Integer.toBinaryString(n); char[] c=s.toCharArray(); int j=0; for(int i=0;i&lt;c.length;i++)&#123; if(c[i]=='1')&#123; j++; &#125; &#125; return j; &#125;&#125; 解析： public static String toBinaryString(int i) 以二进制（基数 2）无符号整数形式返回一个整数参数的字符串表示形式。 ①先把整数转换成二进制字符串 ②把字符串转换成字符数组 ③遍历该数组，判断每位是否为1，为1 计数加1。 ④遍历完成返回1的个数 解法二 运行时间：30ms 占用内存：629k 12345678910public class Solution &#123;public int NumberOf1(int n) &#123; int count =0; while(n!=0)&#123; count++; n = n&amp;(n-1); &#125; return count; &#125;&#125; 解析： 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。 举个例子： ①二进制数 1100 ② 减１后，得 1011 ③1100&amp;1011=1000 对比①和③你会发现，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。 定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。1234567891011121314151617181920212223242526272829303132import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; min = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack.push(node); if(min.isEmpty())&#123; min.push(node); &#125;else&#123; if (node &lt;= min.peek()) &#123; min.push(node); &#125; &#125; &#125; public void pop() &#123; if (stack.peek() == min.peek()) &#123; min.pop(); &#125; stack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int min() &#123; return min.peek(); &#125;&#125; 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。输入描述 str 是StringBuffer的对象 输出描述 返回替换后的字符串的String对象 题目分析 首先要对输入参数进行判空和越界判断（任何算法题都要注意）。 解法一 （运行时间：36ms 占用内存：688k） 1234567891011121314151617public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; if(str==null)&#123; return null; &#125; StringBuffer sb = new StringBuffer(); char [] strChar = str.toString().toCharArray(); for(int i=0;i&lt;strChar.length;i++)&#123; if(strChar[i]==' ')&#123; sb.append("%20"); &#125;else&#123; sb.append(strChar[i]); &#125; &#125; return sb.toString(); &#125;&#125; 把传入的StringBuffer 对象 str 转换成字符串 再转换成字符数组,申请一个新的StringBuffer 对象 sb来存最后的结果，遍历整个字符数组，如果当前字符为空格则把 ＂％２０＂加入到sb中，否则直接追加当前字符，最后把sb转换成字符串返回。 解法二 （运行时间：34ms 占用内存：503k） 1234567891011121314public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; if(str == null)&#123; return null; &#125; for(int i =0;i&lt;str.length();i++)&#123; char c = str.charAt(i); if(c==' ')&#123; str.replace(i,i+1,"%20"); &#125; &#125; return str.toString(); &#125;&#125; public StringBuffer replace(int start, int end, String str) 使用给定 String 中的字符替换此序列的子字符串中的字符。该子字符串从指定的 start 处开始，一直到索引 end - 1 处的字符，如果不存在这种字符，则一直到序列尾部。先将子字符串中的字符移除，然后将指定的 String 插入 start。（如果需要，序列将延长以适应指定的字符串。）参数：start - 起始索引（包含）。end - 结束索引（不包含）。str - 将替换原有内容的字符串。返回：此对象。 源码（可以看出它调用的是父类的方法） 12345 public synchronized StringBuffer More ...replace(int start, int end, String str)&#123; toStringCache = null; super.replace(start, end, str); return this;&#125; 父类AbstractStringBuilder 12345678910111213141516171819public AbstractStringBuilder More ...replace(int start, int end, String str) &#123; if (start &lt; 0) throw new StringIndexOutOfBoundsException(start); if (start &gt; count) throw new StringIndexOutOfBoundsException("start &gt; length()"); if (start &gt; end) throw new StringIndexOutOfBoundsException("start &gt; end"); if (end &gt; count) end = count; int len = str.length(); int newCount = count + len - (end - start); ensureCapacityInternal(newCount); System.arraycopy(value, end, value, start + len, count - end); str.getChars(value, start); count = newCount; return this;&#125; 可以看出StringBuffer类 提供了 插入的函数，值得注意的是 StringBuilder 也是继承于AbstractStringBuilder这个抽象类的。所以它也有这个方法，但是String并没有。 解法三（不推荐，运行时间：38ms 占用内存：654k） 12345public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; return str.toString().replaceAll("\\s", "%20"); &#125;&#125; 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 结果请按字母顺序输出。输入描述 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 输出描述 顺序输出字符串的所有排列 题目分析 这是一个字符串全排列的问题，把全部序列存在TreeSet中默认可得到字典顺序。 TreeSet 基于TreeMap实现的SortedSet，可以对Set集合中的元素进行排序，排序后按升序排列元素（缺省是按照自然排序），非线程安全。 思路： 固定一个字符串之后，之后再将问题变小，只需求出后面子串的排列个数就可以得出结果，然后依次将后面的字符串与前面的交换，再递归子串的排列结果，最后当所有字符都固定结束递归。 下面这张图很清楚的给出了递归的过程： 解法 运行时间：131ms 占用内存：1477k 12345678910111213141516171819202122232425262728293031323334import java.util.*;public class Solution &#123; //用于最后返回结果 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //遍历的时候来存储序列实现排序 TreeSet&lt;String&gt; set = new TreeSet&lt;&gt;(); public ArrayList&lt;String&gt; Permutation(String str) &#123; if(str==null || str.length()==0) return list; Permutation(str.toCharArray(),0); //容器转换，TreeSet中的元素已经是按照字母顺序排序，所以这里做了排序 list.addAll(set); return list; &#125; public void Permutation(char[] s,int index)&#123; if(s==null ||s.length==0 || index&lt;0 || index&gt;s.length-1) return ; if(index==s.length-1)&#123;//递归固定到最后一个位置，把该串加入集合 // set不能添加重复元素，所以这里的add()解决了有重复字符的问题 set.add(new String(s)); &#125;else&#123;//固定前index+1个字符，递归后面所有可能的子串 for(int i = index;i&lt;s.length;i++)&#123; swap(s,index,i);//交换一次形成一个子串 Permutation(s,index+1); swap(s,i,index);//复原使下次循环产生下一个子串 &#125; &#125; &#125; public void swap(char[] s,int i,int j)&#123; char temp = s[i]; s[i] = s[j]; s[j] = temp; &#125;&#125; 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 思路一：数组排序后，如果符合条件的数存在，则一定是数组中间那个数。（比如：1，2，2，2，3；或2，2，2，3，4；或2，3，4，4，4等等） 这种方法虽然容易理解，但由于涉及到快排sort，其时间复杂度为O(NlogN)并非最优； 参考代码如下： 12345678910111213141516171819class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; // 因为用到了sort，时间复杂度O(NlogN)，并非最优 if(numbers.empty()) return 0; sort(numbers.begin(),numbers.end()); // 排序，取数组中间那个数 int middle = numbers[numbers.size()/2]; int count=0; // 出现次数 for(int i=0;i&lt;numbers.size();++i) &#123; if(numbers[i]==middle) ++count; &#125; return (count&gt;numbers.size()/2) ? middle : 0; &#125;&#125;; 思路二：如果有符合条件的数字，则它出现的次数比其他所有数字出现的次数和还要多。 在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。然后再判断它是否符合条件即可。 参考代码如下： 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if(numbers.empty()) return 0; // 遍历每个元素，并记录次数；若与前一个元素相同，则次数加1，否则次数减1 int result = numbers[0]; int times = 1; // 次数 for(int i=1;i&lt;numbers.size();++i) &#123; if(times == 0) &#123; // 更新result的值为当前元素，并置次数为1 result = numbers[i]; times = 1; &#125; else if(numbers[i] == result) &#123; ++times; // 相同则加1 &#125; else &#123; --times; // 不同则减1 &#125; &#125; // 判断result是否符合条件，即出现次数大于数组长度的一半 times = 0; for(int i=0;i&lt;numbers.size();++i) &#123; if(numbers[i] == result) ++times; &#125; return (times &gt; numbers.size()/2) ? result : 0; &#125;&#125;; 斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。输入描述 一个整数n 输出描述 斐波那契数列的第n项。 题目分析 什么是斐波那契数列？ 斐波那契数列（Fibonacci sequence），又称黄金分割数列 在数学上，斐波纳契数列以如下被以递归的方法定义：F（0）=0，F（1）=1，F（n）=F(n-1)+F(n-2)（n≥2，n∈N*） 指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、…… 递归？ 看到这个的第一想法就是用递归，当ｎ＜２时返回ｎ，ｎ＞＝２时返回ｆ(n-1)+f(n-2), 于是就来试一下… 123456789public class Solution &#123; public int Fibonacci(int n) &#123; if(n&lt;2)&#123; return n; &#125; return Fibonacci(n-1)+Fibonacci(n-2); &#125;&#125; 运行超时:您的程序未能在规定时间内运行结束，请检查是否循环有错或算法复杂度过大。 为什么呢？ 因为重复计算，比如： 123ｆ(4) = ｆ(3) + ｆ(2); = ｆ(2) + ｆ(1) + ｆ(1) + ｆ(0); = ｆ(1) + ｆ(0) + ｆ(1) + ｆ(1) + ｆ(0); 求ｆ(4)就要计算三次ｆ(1)和两次ｆ(0)，显然这是不行的。 解法 (动态规划) 运行时间：27ms 占用内存：629k 12345678910public class Solution &#123; public int Fibonacci(int n) &#123; int i = 0, j = 1; for(;n&gt;0;n--)&#123; j += i; i = j-i; &#125; return i; &#125;&#125; 1234567891011121314151617public class Solution &#123; public int Fibonacci(int n) &#123; int a=1,b=1,c=0; if(n&lt;0)&#123; return 0; &#125;else if(n==1||n==2)&#123; return 1; &#125;else&#123; for (int i=3;i&lt;=n;i++)&#123; c=a+b; b=a; a=c; &#125; return c; &#125; &#125;&#125; 根据n的大小，从f(0)=i 和 f(1)=j 从头开始遍历整个序列 有f(n)=f(n-1)+f(n-2) （n≥2，n∈N*） j+=i, 使j成为新的f(n-1)i = j-i ，使i成为f(n-2) 完成后，返回 f(n-2) 注意：java中 while(n–) 会报编译错误： required: booleanfound: int 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法该题答案和上题一样，其实就是斐波那契数列 题目分析 设n阶的跳数为f(n) 当n=1时，f(1) = 1 当n=2时，分为最后一步 跳2阶和跳1阶 两种情况，有f(2)=f(0)+f(1)=1+1=2 当n=3时，分为最后一步 跳3阶、跳2阶和跳1阶 三种情况，有f(3)=f(0)+f(1)+f(2)=1+1+2=4 有 f(n) = f(n-1)+f(n-2)+…+f(1) + f(0)成立同时有 f(n-1)＝f(n-2)+…+f(1) + f(0) 成立，可得出f(n)=2f(n-1) (n&gt;=2) 很明显可以得出递推公式： | 1 (n=0 ) f(n) = | 1 (n=1 ) | 2*f(n-1) (n&gt;=2) 解法一 运行时间：35ms 占用内存：654k 123456public class Solution &#123; public int JumpFloorII(int target) &#123; if(target&lt;=1) return 1; return 2*JumpFloorII(target-1); &#125;&#125; 解法二 运行时间：34ms 占用内存：654k 123456public class Solution &#123; public int JumpFloorII(int target) &#123; if(target&lt;=1) return 1; return 1&lt;&lt;(target-1); &#125;&#125; 换一种思路想一下：一共有ｎ个台阶，最后一个台阶是一定要跳上去的，其他的 ｎ－１个可跳可不跳，一共有多少总情况？ ２（ｎ－１） 这里用移位实现乘法，时间上要快一些！ 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减序列的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。123456789101112131415import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; if(array.length==0)&#123; return 0; &#125; for(int i =0;i&lt;array.length-2;i++)&#123; if(array[i+1] &lt; array[i])&#123; return array[i+1]; &#125; &#125; return array[0]; &#125;&#125; 123456789101112131415161718import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; // 二分法 int low = 0 ; int high = array.length - 1; while(low &lt; high)&#123; int mid = low + (high - low) / 2; if(array[mid] &gt; array[high])&#123; low = mid + 1; &#125;else if(array[mid] == array[high])&#123; high = high - 1; &#125;else&#123; high = mid; &#125; &#125; return array[low]; &#125;&#125; 我们可以用 2 1 的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？输入描述 一个大矩形 输出描述 覆盖的方法数 题目分析 设 被n个2*1的小矩形无重叠地覆盖的方法总数为 f(n) 当n=1时，明显f(1)=1; 当n=2时，只能两个都横着或两个都竖着放，有f(2)=2; 当小矩形个数为n，来覆盖这个2*n的大矩形。第一步只有两种放法： ①竖着放，那么剩下的摆放总数为 f(n-1) ②横着放，那么剩下的摆放总数为 f(n-２)。因为它下面的那块也跟随着它的摆放而确定（必须是一个横着放的小矩形）。 很容易看出满足斐波那契数列。 斐波那契数列（Fibonacci sequence），又称黄金分割数列 在数学上，斐波纳契数列以如下被以递归的方法定义：F（0）=0，F（1）=1，F（n）=F(n-1)+F(n-2)（n≥2，n∈N*） 指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、…… 可以得出递推公式： | 1 (n=0 ) f(n) = | 1 (n=1 ) | f(ｎ-1)＋f(n-2) (n&gt;=2) 解法一 （递归） 运行时间：924ms 占用内存：654k 123456public class Solution &#123; public int RectCover(int target) &#123; if(target&lt;=1) return 1; return RectCover(target-1)+RectCover(target-2); &#125;&#125; 递归效率不高，重复计算多，比如： 123ｆ(4) = ｆ(3) + ｆ(2); = ｆ(2) + ｆ(1) + ｆ(1) + ｆ(0); = ｆ(1) + ｆ(0) + ｆ(1) + ｆ(1) + ｆ(0); 求ｆ(4)就要计算三次ｆ(1)和两次ｆ(0)，显然这是不行的。 解法二（动态规划） 运行时间：29ms 占用内存：629k 123456789101112public class Solution &#123; public int RectCover(int target) &#123; if(target&lt;=1) return 1; int i =1;//f(0) int j =1;//f(1) for(;target&gt;=2;target--)&#123; j+=i; i=j-i; &#125; return j; &#125;&#125; 显然这个快很多，n&gt;=2时，根据 f(n)=f(ｎ-1)＋f(n-2)进行依次计算，最后得出 f（target）并返回。 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 解法二 运行时间：27ms 占用内存：503k 123456789101112131415161718public class Solution &#123; public void reOrderArray(int [] array) &#123; if(array.length==0 || array==null)&#123; return; &#125; for(int i=0;i&lt;array.length-1;i++)&#123; for(int j=0;j&lt;array.length-i-1;j++)&#123; if(array[j]%2==0 &amp;&amp; array[j+1]%2==1)&#123; int temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; &#125; &#125; &#125; &#125;&#125; 类似于冒泡排序，以为用到array[j+1]数组不要越界。 有一个容器类 ArrayList，保存整数类型的元素，现在要求编写一个帮助类，类内提供一个帮助函数，帮助函数的功能是删除 容器中&lt;10的元素。LeetCode上股票利益最大化问题剑指offer上第一次只出现一次的字符反转字符串字符串中出现最多的字符。实现stack 的pop和push接口 要求： 1.用基本的数组实现 2.考虑范型 3.考虑下同步问题 4.考虑扩容问题 求素数单例模式——写一个Singleton出来参考：http://yuweiguocn.github.io/java-instance/ 七种方式实现Singleton模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class Test &#123; /** * 单例模式，懒汉式，线程安全 */ public static class Singleton &#123; private final static Singleton INSTANCE = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return INSTANCE; &#125; &#125; /** * 单例模式，懒汉式，线程不安全 */ public static class Singleton2 &#123; private static Singleton2 instance = null; private Singleton2() &#123; &#125; public static Singleton2 getInstance() &#123; if (instance == null) &#123; instance = new Singleton2(); &#125; return instance; &#125; &#125; /** * 单例模式，饿汉式，线程安全，多线程环境下效率不高 */ public static class Singleton3 &#123; private static Singleton3 instance = null; private Singleton3() &#123; &#125; public static synchronized Singleton3 getInstance() &#123; if (instance == null) &#123; instance = new Singleton3(); &#125; return instance; &#125; &#125; /** * 单例模式，懒汉式，变种，线程安全 */ public static class Singleton4 &#123; private static Singleton4 instance = null; static &#123; instance = new Singleton4(); &#125; private Singleton4() &#123; &#125; public static Singleton4 getInstance() &#123; return instance; &#125; &#125; /** * 单例模式，使用静态内部类，线程安全（推荐） */ public static class Singleton5 &#123; private final static class SingletonHolder &#123; private static final Singleton5 INSTANCE = new Singleton5(); &#125; private static Singleton5 getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; /** * 静态内部类，使用枚举方式，线程安全（推荐） */ public enum Singleton6 &#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125; /** * 静态内部类，使用双重校验锁，线程安全（推荐） */ public static class Singleton7 &#123; private volatile static Singleton7 instance = null; private Singleton7() &#123; &#125; public static Singleton7 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton7.class) &#123; if (instance == null) &#123; instance = new Singleton7(); &#125; &#125; &#125; return instance; &#125; &#125;&#125; 二叉树遍历重建二叉树题目： 1输入二叉树的前序遍历和中序遍历的结果,重建出该二叉树。假设前序遍历和中序遍历结果中都不包含重复的数字,例如输入的前序遍历序列 &#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;重建出如图所示的二叉 树。 解题思路： 1前序遍历第一个结点是父结点，中序遍历如果遍历到父结点，那么父结点前面的结点是左子树的结点，后边的结点的右子树的结点，这样我们可以找到左、右子树的前序遍历和中序遍历，我们可以用同样的方法去构建左右子树，可以用递归完成。 代码： 1234567891011121314151617181920212223242526272829303132public class BinaryTreeNode &#123; public static int value; public BinaryTreeNode leftNode; public BinaryTreeNode rightNode;&#125;public class Solution &#123; public static BinaryTreeNode constructCore(int[] preorder, int[] inorder) throws Exception &#123; if (preorder == null || inorder == null) &#123; return null; &#125; if (preorder.length != inorder.length) &#123; throw new Exception("长度不一样，非法的输入"); &#125; BinaryTreeNode root = new BinaryTreeNode(); for (int i = 0; i &lt; inorder.length; i++) &#123; if (inorder[i] == preorder[0]) &#123; root.value = inorder[i]; System.out.println(root.value); root.leftNode = constructCore(Arrays.copyOfRange(preorder, 1, i + 1), Arrays.copyOfRange(inorder, 0, i)); root.rightNode = constructCore(Arrays.copyOfRange(preorder, i + 1, preorder.length), Arrays.copyOfRange(inorder, i + 1, inorder.length)); &#125; &#125; return root; &#125;&#125; 数值的整数次方题目： 实现函数double Power(double base,int exponent)，求base的exponent次方，不得使用库函数，同时不需要考虑大数问题。 看到了很多人会这样写： 1234567public static double powerWithExponent(double base,int exponent)&#123; double result = 1.0; for(int i = 1; i &lt;= exponent; i++)&#123; result = result * base; &#125; return result; &#125; 输入的指数(exponent)小于1即是零和负数时怎么办？ 当指数为负数的时候，可以先对指数求绝对值，然后算出次方的结果之后再取倒数，当底数(base)是零且指数是负数的时候，如果不做特殊处理，就会出现对0求倒数从而导致程序运行出错。最后，由于0的0次方在数学上是没有意义的，因此无论是输出0还是1都是可以接受的。 1234567891011121314151617181920212223242526272829303132public double power(double base, int exponent) throws Exception &#123; double result = 0.0; if (equal(base, 0.0) &amp;&amp; exponent &lt; 0) &#123; throw new Exception("0的负数次幂无意义"); &#125; if (equal(exponent, 0)) &#123; return 1.0; &#125; if (exponent &lt; 0) &#123; result = powerWithExponent(1.0 / base, -exponent); &#125; else &#123; result = powerWithExponent(base, exponent); &#125; return result; &#125; private double powerWithExponent(double base, int exponent) &#123; double result = 1.0; for (int i = 1; i &lt;= exponent; i++) &#123; result = result * base; &#125; return result; &#125; // 判断两个double型数据，计算机有误差 private boolean equal(double num1, double num2) &#123; if ((num1 - num2 &gt; -0.0000001) &amp;&amp; (num1 - num2 &lt; 0.0000001)) &#123; return true; &#125; else &#123; return false; &#125; &#125; 一个细节，再判断底数base是不是等于0时，不能直接写base==0，这是因为在计算机内表示小数时(包括float和double型小数)都有误差。判断两个数是否相等，只能判断 它们之间的绝对值是不是在一个很小的范围内。如果两个数相差很小，就可以认为它们相等。 还有更快的方法。 如果我们的目标是求出一个数字的32次方，如果我们已经知道了它的16次方，那么只要在16次方的基础上再平方一次就好了，依此类推，我们求32次方只需要做5次乘法。 我们可以利用如下公式： 1234567891011121314private double powerWithExponent2(double base,int exponent)&#123; if(exponent == 0)&#123; return 1; &#125; if(exponent == 1)&#123; return base; &#125; double result = powerWithExponent2(base, exponent &gt;&gt; 1); result *= result; if((exponent&amp;0x1) == 1)&#123; result *= base; &#125; return result; &#125; 我们用右移运算代替除2，用位与运算符代替了求余运算符（%)来判断一个数是奇数还是偶数。位运算的效率比乘除法及求余运算的效率要高很多。 扑克牌的顺子题目: 1从扑克牌中随机抽 5 张牌,判断是不是顺子,即这 5 张牌是不是连续的。 2-10 为数字本身,A 为 1,J 为 11,Q 为 12,K 为 13,而大小王可以看成任意的 数字。 解题思路：我们可以把5张牌看成是由5个数字组成的俄数组。大小王是特殊的数字，我们可以把它们都定义为0，这样就可以和其他的牌区分开来。 首先把数组排序，再统计数组中0的个数，最后统计排序之后的数组中相邻数字之间的空缺总数。如果空缺的总数小于或者等于0的个数，那么这个数组就是连续的，反之则不连续。如果数组中的非0数字重复出现，则该数组是不连续的。换成扑克牌的描述方式就是如果一幅牌里含有对子，则不可能是顺子。 详细代码： 12345678910111213141516171819202122232425262728293031import java.util.Arrays;public class Solution &#123; public boolean isContinuous(int[] number)&#123; if(number == null)&#123; return false; &#125; Arrays.sort(number); int numberZero = 0; int numberGap = 0; //计算数组中0的个数 for(int i = 0;i &lt; number.length&amp;&amp;number[i] == 0; i++)&#123; numberZero++; &#125; //统计数组中的间隔数目 int small = numberZero; int big = small + 1; while(big&lt;number.length)&#123; //两个数相等，有对子，不可能是顺子 if(number[small] == number[big])&#123; return false; &#125; numberGap+= number[big] - number[small] - 1; small = big; big++; &#125; return (numberGap&gt;numberZero)?false:true; &#125;&#125; 圆圈中最后剩下的数字题目 0,1,…,n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字。求这个圆圈里剩下的最后一个数字。 解法: 可以创建一个总共有n个结点的环形链表，然后每次在这个链表中删除第m个结点。我们发现使用环形链表里重复遍历很多遍。重复遍历当然对时间效率有负面的影响。这种方法每删除一个数字需要m步运算，总共有n个数字，因此总的时间复杂度为O(mn)。同时这种思路还需要一个辅助的链表来模拟圆圈，其空间复杂度O(n）。接下来我们试着找到每次被删除的数字有哪些规律，希望能够找到更加高效的算法。 首先我们定义一个关于n和m的方程f(n,m)，表示每次在n个数字0，1，。。。n-1中每次删除第m个数字最后剩下的数字。 在这n个数字中，第一个被删除的数字是（m-1)%n.为了简单起见，我们把（m-1)%n记为k，那么删除k之后剩下的n-1个数字为0，1，。。。。k-1，k+1,…..n-1。并且下一次删除从数字k+1,……n-1,0,1,….k-1。该序列最后剩下的数字也应该是关于n和m的函数。由于这个序列的规律和前面最初的序列不一样（最初的序列是从0开始的连续序列），因此该函数不同于前面的函数，即为f’(n-1,m)。最初序列最后剩下的数字f(n,m)一定是删除一个数字之后的序列最后剩下的数字，即f(n,m)=f’(n-1,m). 接下来我么把剩下的这n-1个数字的序列k+1,….n-1，0，1，,,,,,,k-1做一个映射，映射的结果是形成一个从0到n-2的序列 12345678k+1 ------&gt; 0k+2 ---------&gt; 1。。。。n-1 ----- &gt; n-k-20 -------&gt; n-k-11 ---------&gt; n-k.....k-1 ---------&gt; n-k 我们把映射定义为p，则p(x) = (x-k-1)%n。它表示如果映射前的数字是x,那么映射后的数字是（x-k-1)%n.该映射的逆映射是p-1(x)= (x+k+1)%n. 由于映射之后的序列和最初的序列具有同样的形式，即都是从0开始的连续序列，因此仍然可以用函数f来表示，记为f(n-1,m).根据我们的映射规则，映射之前的序列中最后剩下的数字f’(n-1,m) = p-1[(n-1,m)] = [f(n-1,m)+k+1]%n ,把k= (m-1)%n代入f(n,m) = f’(n-1,m) =[f(n-1,m)+m]%n. 经过上面的复杂的分析，我们终于找到一个递归的公示。要得到n个数字的序列中最后剩下的数字，只需要得到n-1个数字的序列和最后剩下的数字，并以此类推。当n-1时，也就是序列中开始只有一个数字0，那么很显然最后剩下的数字就是0.我们把这种关系表示为： 代码如下： 12345678910public static int lastRemaining(int n, int m)&#123; if(n &lt; 1 || m &lt; 1)&#123; return -1; &#125; int last = 0; for(int i = 2; i &lt;= n; i++)&#123; last = (last + m) % i; &#125; return last; &#125; two-sumQuestion 12345Given an array of integers, find two numbers such that they add up to a specific target number.The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.You may assume that each input would have exactly one solution.Input: numbers=&#123;2, 7, 11, 15&#125;, target=9Output: index1=1, index2=2 题目大意： 12给定一个整数数组，找到2个数字，这样他们就可以添加到一个特定的目标号。功能twosum应该返回两个数字，他们总计达目标数，其中index1必须小于index2。请注意，你的答案返回（包括指数和指数）不为零的基础。你可以假设每个输入都有一个解决方案。输入数字numbers= &#123; 2，7，11，15 &#125;，目标= 9输出：index1 = 1，index2= 2 解题思路： 1可以申请额外空间来存储目标数减去从头遍历的数，记为key，如果hashMap中存在该key，就可以返回两个索引了。 代码； 123456789101112131415161718import java.util.HashMap;public class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; numbers.length; i++)&#123; if(map.get(numbers[i]) != null)&#123; int[] result = &#123;map.get(numbers[i]) + 1, i+1&#125;; return result; &#125;else &#123; map.put(target - numbers[i], i); &#125; &#125; int[] result = &#123;&#125;; return result; &#125;&#125; 设计一个有getMin功能的栈实现一个特殊的栈，在实现栈的基本功能的基础上，在实现返回栈中最小元素的操作。 要求： pop、push、getMin操作的时间复杂度都是O(1) 设计的栈类型可以使用现成的栈结构 解题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package chapter01_stackandqueue;import java.util.Stack;/** * * 实现一个特殊的栈，在实现栈的基本功能的基础上，在实现返回栈中最小元素的操作。 要求： 1. pop、push、getMin操作的时间复杂度都是O(1) * 2. 设计的栈类型可以使用现成的栈结构 * * @author dream * */public class Problem01_GetMinStack &#123; public static class MyStack1 &#123; /** * 两个栈，其中stacMin负责将最小值放在栈顶，stackData通过获取stackMin的peek()函数来获取到栈中的最小值 */ private Stack&lt;Integer&gt; stackData; private Stack&lt;Integer&gt; stackMin; /** * 在构造函数里面初始化两个栈 */ public MyStack1() &#123; stackData = new Stack&lt;Integer&gt;(); stackMin = new Stack&lt;Integer&gt;(); &#125; /** * 该函数是stackData弹出栈顶数据，如果弹出的数据恰好等于stackMin的数据，那么stackMin也弹出 * @return */ public Integer pop() &#123; Integer num = (Integer) stackData.pop(); if (num == getmin()) &#123; return (Integer) stackMin.pop(); &#125; return null; &#125; /** * 该函数是先判断stackMin是否为空，如果为空，就push新的数据，如果这个数小于stackMin中的栈顶元素，那么stackMin需要push新的数，不管怎么样 * stackData都需要push新的数据 * @param value */ public void push(Integer value) &#123; if (stackMin.isEmpty()) &#123; stackMin.push(value); &#125; else if (value &lt; getmin()) &#123; stackMin.push(value); &#125; stackData.push(value); &#125; /** * 该函数是当stackMin为空的话第一次也得push到stackMin的栈中，返回stackMin的栈顶元素 * @return */ public Integer getmin() &#123; if (stackMin == null) &#123; throw new RuntimeException("stackMin is empty"); &#125; return (Integer) stackMin.peek(); &#125; &#125; public static void main(String[] args) throws Exception &#123; /** * 要注意要将MyStack1声明成静态的，静态内部类不持有外部类的引用 */ MyStack1 stack1 = new MyStack1(); stack1.push(3); System.out.println(stack1.getmin()); stack1.push(4); System.out.println(stack1.getmin()); stack1.push(1); System.out.println(stack1.getmin()); System.out.println(stack1.pop()); System.out.println(stack1.getmin()); System.out.println("============="); &#125;&#125; 由两个栈组成的队列题目： 1编写一个类，用两个栈实现队列，支持队列的基本操作(add、poll、peek)。 解题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * * 编写一个类，用两个栈实现队列，支持队列的基本操作(add、poll、peek)。 * * @author dream * */public class Problem02_TwoStacksImplementQueue &#123; public static class myQueue&#123; Stack&lt;Integer&gt; stack1; Stack&lt;Integer&gt; stack2; public myQueue() &#123; stack1 = new Stack&lt;Integer&gt;(); stack2 = new Stack&lt;Integer&gt;(); &#125; /** * add只负责往stack1里面添加数据 * @param newNum */ public void add(Integer newNum)&#123; stack1.push(newNum); &#125; /** * 这里要注意两点： * 1.stack1要一次性压入stack2 * 2.stack2不为空，stack1绝不能向stack2压入数据 * @return */ public Integer poll()&#123; if(stack1.isEmpty() &amp;&amp; stack2.isEmpty())&#123; throw new RuntimeException("Queue is Empty"); &#125;else if(stack2.isEmpty())&#123; while (!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125; public Integer peek()&#123; if(stack1.isEmpty() &amp;&amp; stack2.isEmpty())&#123; throw new RuntimeException("Queue is Empty"); &#125;else if(stack2.isEmpty())&#123; while (!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.peek(); &#125; &#125; public static void main(String[] args) &#123; myQueue mQueue = new myQueue(); mQueue.add(1); mQueue.add(2); mQueue.add(3); System.out.println(mQueue.peek()); System.out.println(mQueue.poll()); System.out.println(mQueue.peek()); System.out.println(mQueue.poll()); System.out.println(mQueue.peek()); System.out.println(mQueue.poll()); &#125;&#125; 如何仅用递归函数和栈操作逆序一个栈题目： 1一个栈一次压入了1、2、3、4、5，那么从栈顶到栈底分别为5、4、3、2、1.将这个栈转置后，从栈顶到栈底为1、2、3、4、5，也就是实现栈中元素的逆序，但是只能用递归函数来实现，不能用其他数据结构。 解题： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 一个栈一次压入了1、2、3、4、5，那么从栈顶到栈底分别为5、4、3、2、1.将这个栈转置后， * 从栈顶到栈底为1、2、3、4、5， * 也就是实现栈中元素的逆序，但是只能用递归函数来实现，不能用其他数据结构。 * @author dream * */public class Problem03_ReverseStackUsingRecursive &#123; public static void reverse(Stack&lt;Integer&gt; stack) &#123; if (stack.isEmpty()) &#123; return; &#125; int i = getAndRemoveLastElement(stack); reverse(stack); stack.push(i); &#125; /** * 这个函数就是删除栈底元素并返回这个元素 * @param stack * @return */ public static int getAndRemoveLastElement(Stack&lt;Integer&gt; stack) &#123; int result = stack.pop(); if (stack.isEmpty()) &#123; return result; &#125; else &#123; int last = getAndRemoveLastElement(stack); stack.push(result); return last; &#125; &#125; public static void main(String[] args) &#123; Stack&lt;Integer&gt; test = new Stack&lt;Integer&gt;(); test.push(1); test.push(2); test.push(3); test.push(4); test.push(5); reverse(test); while (!test.isEmpty()) &#123; System.out.println(test.pop()); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 面试之排序算法]]></title>
      <url>http://eddy.wiki/interview-algorithm.html</url>
      <content type="text"><![CDATA[本文出自 Eddy Wiki ，转载请注明出处：http://eddy.wiki/interview-algorithm.html 本文收集整理了排序、查找算法相关的知识。 排序算法参考 排序算法过程演示动画 九大基础排序总结和对比 各种排序算法的分析及java实现 选择排序 背景介绍： 选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 —– 来自 wikipedia 算法规则： 将待排序集合(0…n)看成两部分，在起始状态中，一部分为(k..n)的待排序unsorted集合，另一部分为(0…k)的已排序sorted集合,在待排序集合中挑选出最小元素并且记录下标i，若该下标不等于k，那么 unsorted[i] 与 sorted[k]交换 ，一直重复这个过程，直到unsorted集合中元素为空为止。 代码实现（Java版本） 1234567891011121314151617public void sort(int[] args) &#123; int len = args.length; for (int i = 0,k = 0; i &lt; len; i++,k = i) &#123; // 在这一层循环中找最小 for (int j = i + 1; j &lt; len; j++) &#123; // 如果后面的元素比前面的小，那么就交换下标，每一趟都会选择出来一个最小值的下标 if (args[k] &gt; args[j]) k = j; &#125; if (i != k) &#123; int tmp = args[i]; args[i] = args[k]; args[k] = tmp; &#125; &#125; &#125; 冒泡排序 背景介绍： 是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。—– 来自 wikipedia 算法规则： 由于算法每次都将一个最大的元素往上冒，我们可以将待排序集合(0…n)看成两部分，一部分为(k..n)的待排序unsorted集合，另一部分为(0…k)的已排序sorted集合，每一次都在unsorted集合从前往后遍历，选出一个数，如果这个数比其后面的数大，则进行交换。完成一轮之后，就肯定能将这一轮unsorted集合中最大的数移动到集合的最后，并且将这个数从unsorted中删除，移入sorted中。 代码实现（Java版本） 123456789101112131415public void sort(int[] args) &#123; //第一层循环从数组的最后往前遍历 for (int i = args.length - 1; i &gt; 0 ; --i) &#123; //这里循环的上界是 i - 1，在这里体现出 “将每一趟排序选出来的最大的数从sorted中移除” for (int j = 0; j &lt; i; j++) &#123; //保证在相邻的两个数中比较选出最大的并且进行交换(冒泡过程) if (args[j] &gt; args[j+1]) &#123; int temp = args[j]; args[j] = args[j+1]; args[j+1] = temp; &#125; &#125; &#125; &#125; 快速排序 背景介绍： 又称划分交换排序（partition-exchange sort），一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来 —– 来自 wikipedia ** 算法规则： 本质来说，快速排序的过程就是不断地将无序元素集递归分割，一直到所有的分区只包含一个元素为止。 由于快速排序是一种分治算法，我们可以用分治思想将快排分为三个步骤： 1.分：设定一个分割值，并根据它将数据分为两部分 2.治：分别在两部分用递归的方式，继续使用快速排序法 3.合：对分割的部分排序直到完成 代码实现（Java版本） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public int dividerAndChange(int[] args, int start, int end) &#123; //标准值 int pivot = args[start]; while (start &lt; end) &#123; // 从右向左寻找，一直找到比参照值还小的数值，进行替换 // 这里要注意，循环条件必须是 当后面的数 小于 参照值的时候 // 我们才跳出这一层循环 while (start &lt; end &amp;&amp; args[end] &gt;= pivot) end--; if (start &lt; end) &#123; swap(args, start, end); start++; &#125; // 从左向右寻找，一直找到比参照值还大的数组，进行替换 while (start &lt; end &amp;&amp; args[start] &lt; pivot) start++; if (start &lt; end) &#123; swap(args, end, start); end--; &#125; &#125; args[start] = pivot; return start;&#125;public void sort(int[] args, int start, int end) &#123; //当分治的元素大于1个的时候，才有意义 if ( end - start &gt; 1) &#123; int mid = 0; mid = dividerAndChange(args, start, end); // 对左部分排序 sort(args, start, mid); // 对右部分排序 sort(args, mid + 1, end); &#125;&#125;private void swap(int[] args, int fromIndex, int toIndex) &#123; args[fromIndex] = args[toIndex];&#125; 归并排序 背景介绍： 是创建在归并操作上的一种有效的排序算法，效率为O(n log n)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。 —– 来自 wikipedia 算法规则： 像快速排序一样，由于归并排序也是分治算法，因此可使用分治思想： 1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 2.设定两个指针，最初位置分别为两个已经排序序列的起始位置 3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 4.重复步骤3直到某一指针到达序列尾 5.将另一序列剩下的所有元素直接复制到合并序列尾 代码实现（Java版本） 123456789101112131415161718192021222324252627282930313233343536public void mergeSort(int[] ints, int[] merge, int start, int end) &#123; if (start &gt;= end) return; int mid = (end + start) &gt;&gt; 1; mergeSort(ints, merge, start, mid); mergeSort(ints, merge, mid + 1, end); merge(ints, merge, start, end, mid);&#125;private void merge(int[] a, int[] merge, int start, int end,int mid) &#123; int i = start; int j = mid+1; int pos = start; while( i &lt;= mid || j &lt;= end )&#123; if( i &gt; mid )&#123; while( j &lt;= end ) merge[pos++] = a[j++]; break; &#125; if( j &gt; end )&#123; while( i &lt;= mid ) merge[pos++] = a[i++]; break; &#125; merge[pos++] = a[i] &gt;= a[j] ? a[j++] : a[i++]; &#125; for (pos = start; pos &lt;= end; pos++) a[pos] = merge[pos];&#125; 折半查找基本原理：每次查找都对半分，但要求数组是有序的 12345678910111213141516171819public class Solution &#123; public static int BinarySearch(int[] sz,int key)&#123; int low = 0; int high = sz.length - 1; while (low &lt;= high) &#123; int middle = (low + high) / 2; if(sz[middle] == key)&#123; return middle; &#125;else if(sz[middle] &gt; key)&#123; high = middle - 1; &#125;else &#123; low = middle + 1; &#125; &#125; return -1; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 面试之常用开源库]]></title>
      <url>http://eddy.wiki/interview-opensource.html</url>
      <content type="text"><![CDATA[本文出自 Eddy Wiki ，转载请注明出处：http://eddy.wiki/interview-opensource.html 本文收集整理了 Android 中常用的一些开源库。 图片加载开源库参考： Android开源项目推荐之「图片加载到底哪家强」 网络请求开源库参考： Android开源项目推荐之「网络请求哪家强」 Volley 源码解析参考： http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90 Volley的磁盘缓存在面试的时候，聊到 Volley 请求到网络的数据缓存。当时说到是 Volley 会将每次通过网络请求到的数据，采用FileOutputStream，写入到本地的文件中。那么问题来了：这个缓存文件，是声明在一个SD卡文件夹中的(也可以是getCacheFile())。如果不停的请求网络数据，这个缓存文件夹将无限制的增大，最终达到SD卡容量时，会发生无法写入的异常(因为存储空间满了)。这个问题的确以前没有想到，当时也没说出怎么回事。回家了赶紧又看了看代码才知道，原来 Volley 考虑过这个问题(汗!想想也是)翻看代码DiskBasedCache#pruneIfNeeded() 1234567891011121314151617181920212223242526private void pruneIfNeeded(int neededSpace) &#123; if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes) &#123; return; &#125; long before = mTotalSize; int prunedFiles = 0; long startTime = SystemClock.elapsedRealtime(); Iterator&lt;Map.Entry&lt;String, CacheHeader&gt;&gt; iterator = mEntries.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;String, CacheHeader&gt; entry = iterator.next(); CacheHeader e = entry.getValue(); boolean deleted = getFileForKey(e.key).delete(); if (deleted) &#123; mTotalSize -= e.size; &#125; else &#123; //print log &#125; iterator.remove(); prunedFiles++; if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes * HYSTERESIS_FACTOR) &#123; break; &#125; &#125;&#125; 其中mMaxCacheSizeInBytes是构造方法传入的一个缓存文件夹的大小，如果不传默认是5M的大小。通过这个方法可以发现，每当被调用时会传入一个neededSpace，也就是需要申请的磁盘大小(即要新缓存的那个文件所需大小)。首先会判断如果这个neededSpace申请成功以后是否会超过最大可用容量，如果会超过，则通过遍历本地已经保存的缓存文件的header(header中包含了缓存文件的缓存有效期、占用大小等信息)去删除文件，直到可用容量不大于声明的缓存文件夹的大小。其中HYSTERESIS_FACTOR是一个值为0.9的常量，应该是为了防止误差的存在吧(我猜的)。 Volley缓存命中率的优化如果让你去设计Volley的缓存功能，你要如何增大它的命中率。可惜了，如果上面的缓存功能是昨天看的，今天的面试这个问题就能说出来了。还是上面的代码，在缓存内容可能超过缓存文件夹的大小时，删除的逻辑是直接遍历header删除。这个时候删除的文件有可能是我们上一次请求时刚刚保存下来的，屁股都还没坐稳呢，现在立即删掉，有点舍不得啊。如果遍历的时候，判断一下，首先删除超过缓存有效期的(过期缓存)，其次按照LRU算法，删除最久未使用的，岂不是更合适？ Volley缓存文件名的计算这个是我一直没弄懂的问题。如下代码： 123456private String getFilenameForKey(String key) &#123; int firstHalfLength = key.length() / 2; String localFilename = String.valueOf(key.substring(0, firstHalfLength).hashCode()); localFilename += String.valueOf(key.substring(firstHalfLength).hashCode()); return localFilename;&#125; 为什么会要把一个key分成两部分，分别求hashCode，最后又做拼接。这个问题之前在stackoverflow上问过 #链接原谅我，别人的回答我最初并没有看懂。直到最近被问到，如果让你设计一个HashMap，如何避免value被覆盖，我才想到原因。先来看一下 String#hashCode() 的实现： 123456789101112131415@Override public int hashCode() &#123; int hash = hashCode; if (hash == 0) &#123; if (count == 0) &#123; return 0; &#125; final int end = count + offset; final char[] chars = value; for (int i = offset; i &lt; end; ++i) &#123; hash = 31*hash + chars[i]; &#125; hashCode = hash; &#125; return hash;&#125; 从上面的实现可以看到，String的hashcode是根据字符数组中每个位置的字母的int值再加上上次hash值乘以31，这种算法求出来的，至于为什么是31，我也不清楚。但是可以肯定一点，hashcode并不是唯一的。不信你运行下面这两个输出： 12System.out.print(&quot;======&quot; + &quot;vFrKiaNHfF7t[9::E[XsX?L7xPp3DZSteIZvdRT8CX:w6d;v&lt;_KZnhsM_^dqoppe&quot;.hashCode());System.out.print(&quot;======&quot; + &quot;hI4pFxGOfS@suhVUd:mTo_begImJPB@Fl[6WJ?ai=RXfIx^=Aix@9M;;?Vdj_Zsi&quot;.hashCode()); 这两个字符串是根据hashcode的算法逆向出来的，他们的hashcode都是12345。逆向算法请见这里再回到我们的问题，为什么会要把一个key分成两部分。现在可以肯定的答出，目的是为了尽可能避免hashcode重复造成的文件名重复(求两次hash两次都与另一个url重复的概率总要比一次重复的概率小吧)。顺带再提一点，就像上面说的，概率小并不代表不存在。但是Java计算hashcode的速度是很快的，应该是在效率和安全性上取舍的结果吧。 Glide源码解析参考： http://www.lightskystreet.com/2015/10/12/glide_source_analysis/ http://frodoking.github.io/2015/10/10/android-glide/ Retrofit源码分析参考： Retrofit源码分析 EventBus源码分析参考： EventBus源码分析 greenDAO参考： Android ORM 框架之 greenDAO 使用心得 RxJava参考： RxJava]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 面试之某些公司的面试题]]></title>
      <url>http://eddy.wiki/interview-company.html</url>
      <content type="text"><![CDATA[本文出自 Eddy Wiki ，转载请注明出处：http://eddy.wiki/interview-company.html 本文从网络上收集了一些公司的 Android 面试题。 Alibaba一面 说一下你怎么学习安卓的？ 项目中遇到哪些问题，如何解决的？ Android事件分发机制？ 三级缓存底层实现？ HashMap底层实现，hashCode如何对应bucket? Java的垃圾回收机制，引用计数法两个对象互相引用如何解决？ 用过的开源框架的源码分析 Acticity的生命周期，Activity异常退出该如何处理？ tcp和udp的区别，tcp如何保证可靠的，丢包如何处理？ 二面： 标号1-n的n个人首尾相接，1到3报数，报到3的退出，求最后一个人的标号 给定一个字符串，求第一个不重复的字符 abbcad -&gt; c 新浪微博 一面静态内部类、内部类、匿名内部类，为什么内部类会持有外部类的引用？持有的引用是this？还是其它？ 123静态内部类：使用static修饰的内部类匿名内部类：使用new生成的内部类因为内部类的产生依赖于外部类，持有的引用是类名.this。 ArrayList和Vector的主要区别是什么？ 1234567891011ArrayList在Java1.2引入，用于替换VectorVector:线程同步当Vector中的元素超过它的初始大小时，Vector会将它的容量翻倍ArrayList:线程不同步，但性能很好当ArrayList中的元素超过它的初始大小时，ArrayList只增加50%的大小 Java集合类框架 Java中try catch finally的执行顺序 1先执行try中代码发生异常执行catch中代码，最后一定会执行finally中代码 switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？ 1switch支持使用byte类型，不支持long类型，String支持在java1.7引入 Activity和Fragment生命周期有哪些？ 123Activity——onCreate-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onDestroyFragment——onAttach-&gt;onCreate-&gt;onCreateView-&gt;onActivityCreated-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onDestroyView-&gt;onDestroy-&gt;onDetach onInterceptTouchEvent()和onTouchEvent()的区别？ 12onInterceptTouchEvent()用于拦截触摸事件onTouchEvent()用于处理触摸事件 RemoteView在哪些功能中使用 1APPwidget和Notification中 SurfaceView和View的区别是什么？ 12SurfaceView中采用了双缓存技术，在单独的线程中更新界面View在UI线程中更新界面 讲一下android中进程的优先级？ 12345前台进程可见进程服务进程后台进程空进程 tips：静态类持有Activity引用会导致内存泄露 二面 service生命周期，可以执行耗时操作吗？ JNI开发流程 Java线程池，线程同步 自己设计一个图片加载框架 自定义View相关方法 http ResponseCode 插件化，动态加载 性能优化，MAT AsyncTask原理 65k限制 Serializable和Parcelable 文件和数据库哪个效率高 断点续传 WebView和JS 所使用的开源框架的实现原理，源码 网易杭研 一面： 自我介绍 Android中ClassLoader和java中有什么关系和区别？ 熟不熟jvm，说一下Jvm的自动内存管理？ 语言基础，String类可以被继承吗？为什么？ Final能修饰什么？（当时我说class、field、method，他说还有吗？然后又叫我不要在意，后来回想起，应该是问到我在参数里面要不要用final，接下来是因为匿名内部类） Java中有内存泄露吗？（先说本质，再结合handler+匿名内部类）当时如何分析的？ 描述下Aidl？觉得aidl有什么缺陷（这里在这个问题上回答有欠缺） 评价一下我，如果顺利进网易，需要往技术栈加什么点尽快投入业务？ 二面： 用过什么开源，举一个例子？（volley） Activity生命周期？情景：现在在一张act1点了新的act2，周期如何？ Act的launchMode，有没有结合项目用过（自己的程序锁和微信的PC端登陆对比，不过我现在又发现，应该大约估计可能是动态加载的一个缺陷，如果有找到相关信息，请务必跟我说。具体问题就是，当在PC端登录时，Android终端的微信会跳出，即使wechat的task不是在fore，当按下确认，返回的是wechat，而不是自己先前的app） View的绘制原理，有没有用canvas自己画过ui？ 以后想做Android什么方向？（中间件+SDK） 怎么看待前端和后端？ 如果学前端会如何学？ 优缺点？兴趣？ 想不想来杭州？ 评价一下我？往技术栈加什么？ 三面HR： 为什么想来网易？ 有投其他公司吗？ 网易最吸引你的是什么？ 想来杭州吗？ 评价一下我？ 美团 一面 自我介绍 面向对象三大特性 Java虚拟机，垃圾回收 GSON RxJava+Retrofit 图片缓存，三级缓存 Android启动模式 四大组件 Fragment生命周期，嵌套 AsyncTask机制 Handler机制 二面 面试官写程序，看错误。 面试官写程序让判断GC引用计数法循环引用会发生什么情况 Android进程间通信，Binder机制 Handler消息机制，postDelayed会造成线程阻塞吗？对内存有什么影响？ Debug和Release状态的不同 实现stack 的pop和push接口 要求： 1.用基本的数组实现 2.考虑范型 3.考虑下同步问题 4.考虑扩容问题 蜻蜓FM 一面 Toolbar的使用 如何判断本地缓存的时候数据需要从网络端获取 跨进程间通信 Handler消息机制 SharedPreference实现 快速排序 项目难点 豌豆荚三面 豌豆荚一面 介绍一下你的项目 网络框架的搭建 图片加载框架的实现 写个图片浏览器，说出你的思路 上网站写代码，如下： 有一个容器类 ArrayList，保存整数类型的元素，现在要求编写一个帮助类，类内提供一个帮助函数，帮助函数的功能是删除 容器中&lt;10的元素。 豌豆荚二面 Activity的启动模式 事件分发机制 写代码，LeetCode上股票利益最大化问题 写代码，剑指offer上第一次只出现一次的字符 豌豆荚三面 聊项目，聊大学做过的事 写代码，反转字符串 写代码，字符串中出现最多的字符。 2016年4月某公司面试题及面试流程。静态内部类、内部类、匿名内部类，为什么内部类会持有外部类的引用？持有的引用是this？还是其它？ 静态内部类：使用static修饰的内部类 内部类：就是在某个类的内部又定义了一个类，内部类所嵌入的类称为外部类 匿名内部类：使用new生成的内部类 因为内部类的产生依赖于外部类，持有的引用是类名.this ArrayList和Vector的主要区别是什么？ArrayList在Java1.2引入，用于替换Vector Vector: 线程同步 当Vector中的元素超过它的初始大小时，Vector会将它的容量翻倍 ArrayList: 线程不同步，但性能很好 当ArrayList中的元素超过它的初始大小时，ArrayList只增加50%的大小 java集合类框架 Java中try catch finally的执行顺序先执行try中代码发生异常执行catch中代码，最后一定会执行finally中代码 switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？switch支持使用byte类型，不支持long类型，String支持在java1.7引入 Activity和Fragment生命周期有哪些？ Activity——onCreate-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onDestroy Fragment——onAttach-&gt;onCreate-&gt;onCreateView-&gt;onActivityCreated-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onDestroyView-&gt;onDestroy-&gt;onDetach onInterceptTouchEvent()和onTouchEvent()的区别？onInterceptTouchEvent()用于拦截触摸事件onTouchEvent()用于处理触摸事件 RemoteView在哪些功能中使用APPwidget和Notification中 SurfaceView和View的区别是什么？SurfaceView中采用了双缓存技术，在单独的线程中更新界面View在UI线程中更新界面 讲一下android中进程的优先级？ 前台进程 可见进程 服务进程 后台进程 空进程 代码查错题，没记下来tips：静态变量持有Activity引用会导致内存泄露 某公司面试题一面 service生命周期，可以执行耗时操作吗？ JNI开发流程 Java线程池，线程同步 自己设计一个图片加载框架 自定义View相关方法 http ResponseCode 插件化，动态加载 性能优化，MAT AsyncTask原理 65k限制 Serializable和Parcelable 文件和数据库哪个效率高 断点续传 WebView和JS Android基础——ServiceAndroid基础——IntentServiceAndroid开发指导——ServiceAndroid开发指导——绑定ServiceAndroid开发指导——进程间通信AIDL Android面试基础知识总结（一） Android面试——APP性能优化 Android中Java和JavaScript交互WebView 远程代码执行漏洞浅析WebView中的Java与JavaScript提供【安全可靠】的多样互通方案 二面 所使用的开源框架的实现原理，源码 没看过，被pass了 去面试之前把用到的开源框架源码分析一定要看看啊 codekk：开源框架源码解析]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 面试之面试官提问篇]]></title>
      <url>http://eddy.wiki/interview-work.html</url>
      <content type="text"><![CDATA[本文出自 Eddy Wiki ，转载请注明出处：http://eddy.wiki/interview-work.html 本文收集整理了 Android 面试中面试官经常会问的问题，例如：自我介绍、职业规划等等。 请简单介绍一下自己（自我介绍）参考： 面试官好，我是XXX，毕业于XXX大学，主修XXX专业。曾先后任职于XXX、XXX、XXX这几家公司，在最后的XXX中担任XXX的岗位，曾负责/参与过XXX、XXX、XXX等XXX级别的项目，并取得了XXX、XXX、XXX、等成绩。在公司中曾获得过XXX、XXX等荣誉/奖项。现在应聘贵公司XXX岗位，希望能得到这个宝贵的机会，非常感谢！ 三分钟自我介绍 如果面试官没有特别强调，那么自我介绍的时间3分钟最合适。你可以根据自我介绍的四部分内容，这样分配时间：第一分钟主要介绍自己的姓名、年龄、学历、专业特长、实践经历等；第二分钟主要介绍个人业绩，应届毕业生可着重介绍相关的在校活动和社会实践的成果；第三分钟可谈谈对应聘职位的理想和对本行业的看法。 一分钟自我介绍 有时候，面试官会规定自我介绍的时间，你应该怎样应对呢？ 面试官规定的自我介绍时间缩短，如“做一个1分钟的自我介绍”。遇到这种情况，你可以精选事先准备的3分钟自我介绍内容，突出“做成过什么”，展现你与应聘职位相关的能力。一般分成以下3点：我是谁？做过什么？想做什么？ 在一段用时1-3分钟的自我介绍中常规的安排是：首先表述个人基本情况（姓名、年龄、学历），然后重点谈自己的社会实践经验或工作经历（说清楚自己有什么和应聘职位相关的技能、成就），最后抒发下自己的职位理想（自己的能力能胜任应聘的职位）。 你是一个什么样的人？优缺点？为什么从上一家公司离职？项目中遇到哪些问题，如何解决的？你解决了哪些自认为有些水平的问题。代码你是怎么管理的，有没得自己的独到见解。为什么你适合这份工作？ 对编程感兴趣。 责任心强，勤奋努力。 具有岗位要求的能力。 你对这个职位的理解是什么？参考： http://www.xuzhoujob.com/News/120143411287.html 3年或5年内的职业规划 了解熟悉公司业务，学习和公司业务相关技术知识，做好自己的本职工作。 继续深入了解学习 Java 和 Android 相关的技术。 负责公司项目核心模块，项目核心人员。 业内专家、架构师。 开发-高级开发-小组经理-部门经理-总监-… 开发-高级开发-深度专家-架构师-行业大牛-… 参考： 程序员到底是一个什么职业？ 你对我们公司了解多少？在接到面试通知后，通过公司网站、招聘网站上该公司简介、网上搜索等对该公司进行一定的了解。重点关注你应聘岗位相关的内容，然后说出自己的了解的情况即可。 为什么想来我们公司？ 我十分看好贵公司所在的行业，我认为贵公司十分重视人才，而且这项工作很适合我，相信自己一定能做好。 我花费了很多时间考虑各种职业的可能性，我认为这方面的工作最适合我，原因是这项工作要求的许多技能都是我擅长的。举例来说，分析问题和解决问题是我的强项，在以前的工作中我能比别人更早发现和解决问题。 公司未来前景吸引我,我喜欢你们公司的人性化管理模式和工作氛围.我相信我的个人能力在你们公司可以得到充分的发挥. 你还有什么问题想要问的吗？回答这个问题需要弄清楚面试的你人是什么职位，然后问合适的问题。 人事： 基本薪资。五险一金（部分公司试用期不缴纳；有些公司不缴纳住房公积金；在意这些的可以在这个环节问清楚）、交多少税（即月薪实际上到手的是多少。最好问清楚月薪税后是多少，否则最后发工资才发现和你想的不一样，影响工作情绪。）。 公司福利等，例如：奖金（年终奖、项目奖、季度奖）、旅游。 试用期多久？ 如何评估员工在试用期内的表现？考核标准是什么呢？ 公司采取了什么样的方法和措施，来保证员工的成长？ 这个职位在贵公司的发展前景是怎么样的？ 技术： 你认为这个岗位的胜任条件是什么，你觉得我跟这个岗位还存在什么样的差距？ 你觉得我还需要加强那些方面的能力？ 刚才您提到的那个问题的某个细节我还不太明白，您能再解释下么？ 公司内部是否有技术分享活动什么之类的 ？ 如果进了公司，具体负责什么项目？项目的具体类型之类的 老板： 贵公司的发展目标和方向是什么？ 与同行业的竞争者相比，贵公司的核心竞争优势在什么地方？ 您觉得这个行业在未来五年会发生怎么样的变化？如何应对这种变化？ 说一下你怎么学习安卓的？官网、自带样例、书籍、各大网站、知乎、简书、CSDN、大神博客、github、开源项目、源码 对产品的一些看法对代码质量的要求对开发流程、团队合作的理解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 面试之简历篇]]></title>
      <url>http://eddy.wiki/interview-resume.html</url>
      <content type="text"><![CDATA[本文出自 Eddy Wiki ，转载请注明出处：http://eddy.wiki/interview-resume.html 在网上搜索了一下，经过浏览筛选出下面6篇关于怎么写技术简历的文章。看完下面这6篇文章后，相信你就知道怎么写出一份合适的技术简历了。 怎么写简历？请参考以下文章： 你真的会写简历么 80%以上简历都是不合格的 Android 面试那些事儿 如何写面向互联网公司的求职简历 禅与写简历的艺术 推荐两个技术简历模板]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 面试之 Android 篇]]></title>
      <url>http://eddy.wiki/interview-android.html</url>
      <content type="text"><![CDATA[本文出自 Eddy Wiki ，转载请注明出处：http://eddy.wiki/interview-android.html 本文收集整理了 Android 面试中会遇到与 Android 知识相关的简述题。 基本概念Android 的四大组件Acitivity、Service、BroadcastReceiver、ContentProvider Activity : 应用程序中，一个Activity通常就是一个单独的屏幕，它上面可以显示一些控件也可以监听并处理用户的事件做出响应。 BroadcastReceiver广播接收器: 应用程序可以使用它对外部事件进行过滤只对感兴趣的外部事件(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然而，它们可以启动一个activity或serice 来响应它们收到的信息，或者用NotificationManager 来通知用户。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。 Service 服务: 一个Service 是一段长生命周期的，没有用户界面的程序，可以用来开发如监控类程序。 Content Provider内容提供者 : android平台提供了Content Provider使一个应用程序的指定数据集提供给其他应用程序。这些数据可以存储在文件系统中、在一个SQLite数据库、或以任何其他合理的方式。其他应用可以通过ContentResolver类(见ContentProviderAccessApp例子)从该内容提供者中获取或存入数据.(相当于在应用外包了一层壳),只有需要在多个应用程序间共享数据是才需要内容提供者。例如，通讯录数据被多个应用程序使用，且必须存储在一个内容提供者中。它的好处:统一数据访问方式。 参考： Android四大基本组件介绍与生命周期 四大组件的具体作用以及用法 Acitivity 用于显示界面，接收用户输入，和用户交互。 Service 运行于后台无界面的程序，用于在后台完成一下任务，例如：音乐播放等。 BroadCast Receiver 接收系统或应用发出的广播并作出响应，例如：电话的呼入呼出等。 Content Provider 用于把APP本身的数据共享给其他APP，提供本APP数据的存取接口给其他APP。 Android平台的framework的层次结构？应用层、应用框架层、中间件（核心库和运行时）、Linux内核 ActivityActivity 生命周期 启动Activity：onCreate-&gt;onStart-&gt;onResume 锁屏或被其它Activity覆盖：onPause-&gt;onStop 解锁或由被覆盖状态再回到前台：onRestart-&gt;onStart-&gt;onResume 跳转到其它Activity或按Home进入后台：onPause-&gt;onStop 退回到此Activity：onRestart-&gt;onStart-&gt;onResume 退出此Activity：onPause-&gt;onStop-&gt;onDestory 对话框弹出不会执行任何生命周期(注：对话框如果是Activity(Theme为Dialog)，还是会执行生命周期的) 从A跳转到B：当B的主题为透明时，A只会执行onPause（A-onPause-&gt;B-(onCreate-&gt;onStart-&gt;onResume)） 从A跳转到B：A-onPause-&gt;B-(onCreate-&gt;onStart-&gt;onResume)-A-onStop(注意是A执行onPause后开始执行B的生命周期，B执行onResume后，A才执行onStop，所以尽量不要在onPause中做耗时操作) 从B返回到A：B-onPause-&gt;A-(onRestart-&gt;onStart-&gt;onResume)-B-(onStop-&gt;onDestroy) Activity和Fragment生命周期有哪些？Activity——onCreate-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onDestroy Fragment——onAttach-&gt;onCreate-&gt;onCreateView-&gt;onActivityCreated-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onDestroyView-&gt;onDestroy-&gt;onDetach Activity四种启动模式的区别（LanchMode 的应用场景） standard 模式 这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。 singleTop 模式 如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。 singleTask 模式 如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。 singleInstance 模式 在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。 设置启动模式的位置在 AndroidManifest.xml 文件中 Activity 元素的 Android:launchMode 属性。 singleTop适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。 singleTask适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 singleInstance应用场景：闹铃的响铃界面。 你以前设置了一个闹铃：上午6点。在上午5点58分，你启动了闹铃设置界面，并按 Home 键回桌面；在上午5点59分时，你在微信和朋友聊天；在6点时，闹铃响了，并且弹出了一个对话框形式的 Activity(名为 AlarmAlertActivity) 提示你到6点了(这个 Activity 就是以 SingleInstance 加载模式打开的)，你按返回键，回到的是微信的聊天界面，这是因为 AlarmAlertActivity 所在的 Task 的栈只有他一个元素， 因此退出之后这个 Task 的栈空了。如果是以 SingleTask 打开 AlarmAlertActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。 Activity中类似onCreate、onStart运用了哪种设计模式，优点是什么模板模式。每次新建一个Actiivty时都会覆盖onCreate，onStart等方法,这些方法在父类中就相当于一个模板。 如何将一个Activity设置成窗口的样式 在AndroidManifest.xml文件中设置当前需要改变成窗口样式的Activity的属性。 1android:theme=&quot;@android:style/Theme.Dialog&quot; 在styles.xml文件中自定义一个主题样式，改主题样式必须继承Dialog的样式. Activity的启动过程 无论是通过Launcher来启动Activity，还是通过Activity内部调用startActivity接口来启动新的Activity，都通过Binder进程间通信进入到ActivityManagerService进程中，并且调用ActivityManagerService.startActivity接口； ActivityManagerService调用ActivityStack.startActivityMayWait来做准备要启动的Activity的相关信息； ActivityStack通知ApplicationThread要进行Activity启动调度了，这里的ApplicationThread代表的是调用ActivityManagerService.startActivity接口的进程，对于通过点击应用程序图标的情景来说，这个进程就是Launcher了，而对于通过在Activity内部调用startActivity的情景来说，这个进程就是这个Activity所在的进程了； ApplicationThread不执行真正的启动操作，它通过调用ActivityManagerService.activityPaused接口进入到ActivityManagerService进程中，看看是否需要创建新的进程来启动Activity； 对于通过点击应用程序图标来启动Activity的情景来说，ActivityManagerService在这一步中，会调用startProcessLocked来创建一个新的进程，而对于通过在Activity内部调用startActivity来启动新的Activity来说，这一步是不需要执行的，因为新的Activity就在原来的Activity所在的进程中进行启动； ActivityManagerService调用ApplicationThread.scheduleLaunchActivity接口，通知相应的进程执行启动Activity的操作； ApplicationThread把这个启动Activity的操作转发给ActivityThread，ActivityThread通过ClassLoader导入相应的Activity类，然后把它启动起来。 window和activity之间关系？WindowManager 的相关知识Activity、Window 和 View 三者的区别 一个 Activity 构造的时候一定会构造一个 Window(PhoneWindow)，并且只有一个。 这个Window会有一个ViewRoot(View、ViewGroup)。 通过addView()加载布局。 WindowMangerService 接收消息，并且回到 Activity 函数，比如onKeyDown()。 Activity 是控制单元，Window 是承载模型，View 是显示视图 一个activity打开另外一个activity，再打开一个activity？回去的时候发生了什么操作？onActivityResult(int requestCode, int resultCode, Intent data)方法的用法；如果你想在Activity中得到新打开Activity关闭后返回的数据，你需要使用系统提供的startActivityForResult(Intent intent,int requestCode)方法打开新的Activity，新的Activity关闭后会向前面的Activity传回数据，为了得到传回的数据，你必须在前面的Activity中重写onActivityResult(int requestCode, int resultCode,Intent data)方法。 不用Service,B页面为音乐播放，从A跳到B，再返回，如何使音乐继续播放？A使用startActivityForResult方法开启B，B类结束时调用finish;A类的Intent有一个子Activity结束事件onActivityResult，在这个事件里继续播放音乐。 内存不足时，怎么保持Activity的一些状态，在哪个方法里面做具体操作？在onSaveInstanceState方法中保存Activity的状态，在onRestoreInstanceState或onCreate方法中恢复Activity的状态 onSaveInstanceState方法 用于保存Activity的状态存储一些临时数据 Activity被覆盖或进入后台，由于系统资源不足被kill会被调用 用户改变屏幕方向会被调用 跳转到其它Activity或按Home进入后台会被调用 会在onStop之前被调用，和onPause的顺序不固定的 onRestoreInstanceState(Bundle savedInstanceState)方法 用于恢复保存的临时数据，此方法的Bundle参数也会传递到onCreate方法中，你也可以在onCreate(Bundle savedInstanceState)方法中恢复数据 onRestoreInstanceState和onCreate的区别：当onRestoreInstanceState被调用时Bundle参数一定是有值的，不用做为null判断，onCreate的Bundle则可能会为null。官方文档建议在此方法中进行数据恢复。 由于系统资源不足被kill之后又回到此Activity会被调用 用户改变屏幕方向重建Activity时会被调用 会在onStart之后被调用 同一个程序不同的Activity如何放在不同的任务栈中？需要为不同的activity设置不同的affinity属性，启动activity的Intent需要包含FLAG_ACTIVITY_NEW_TASK标记。 如何安全退出已调用多个Activity的Application？ 记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。 发送特定广播：在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。 递归退出：在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。 有几种在activity之间切换的方法？startActivity() startActivityForResult() FragmentFragment生命周期 Activity中如何动态的添加Fragment？123456789101112131415161718//向活动添加碎片,根据屏幕的纵向和横向显示//1,获取碎片管理器FragmentManager fragment=getFragmentManager();//2,碎片的显示需要使用FragmentTransaction类操作FragmentTransaction transacction=fragment.beginTransaction();//获取屏幕管理器和默认的显示Display display=getWindowManager().getDefaultDisplay();//判断横屏if(display.getWidth()&gt;display.getHeight())&#123; //获取java类 Frament1 frament1 = new Frament1(); transacction.replace(android.R.id.content, frament1);&#125;else&#123; Frament2 frament2 = new Frament2(); transacction.replace(android.R.id.content, frament2);&#125;//使用FragmentTransaction必须要committransacction.commit(); Fragment 特点 Fragment可以作为Activity界面的一部分组成出现； 可以在一个Activity中同时出现多个Fragment，并且一个Fragment也可以在多个Activity中使用； 在Activity运行过程中，可以添加、移除或者替换Fragment； Fragment可以响应自己的输入事件，并且有自己的生命周期，它们的生命周期会受宿主Activity的生命周期影响。 Fragment可以轻松得创建动态灵活的UI设计，可以适应于不同的屏幕尺寸。从手机到平板电脑。 Fragment 解决Activity间的切换不流畅，轻量切换。 Fragment 替代TabActivity做导航，性能更好。 Fragment做局部内容更新更方便，原来为了达到这一点要把多个布局放到一个activity里面，现在可以用多Fragment来代替，只有在需要的时候才加载Fragment，提高性能。 Fragment嵌套多个Fragment会出现bug吗？参考：http://blog.csdn.net/megatronkings/article/details/51417510 怎么理解Activity和Fragment的关系？ Fragment 拥有和 Activity 一致的生命周期，它和 Activity 一样被定义为 Controller 层的类。有过中大型项目开发经验的开发者，应该都会遇到过 Activity 过于臃肿的情况，而 Fragment 的出现就是为了缓解这一状况，可以说 它将屏幕分解为多个「Fragment（碎片）」（这句话很重要），但它又不同于 View，它干的实质上就是 Activity 的事情，负责控制 View 以及它们之间的逻辑。 将屏幕碎片化为多个 Fragment 后，其实 Activity 只需要花精力去管理当前屏幕内应该显示哪些 Fragments，以及应该对它们进行如何布局就行了。这是一种组件化的思维，用 Fragment 去组合了一系列有关联的 UI 组件，并管理它们之间的逻辑，而 Activity 负责在不同屏幕下（例如横竖屏）布局不同的 Fragments 组合。 这种碎片不单单能管理可视的 Views，它也能执行不可视的 Tasks，它提供了 retainInstance 属性，能够在 Activity 因为屏幕状态发生改变（例如切换横竖屏时）而销毁重建时，依然保留实例。这示意着我们能在 RetainedFragment 里面执行一些在屏幕状态发生改变时不被中断的操作。例如使用 RetainedFragment 来缓存在线音乐文件，它在横竖屏切换时依然维持下载进度，并通过一个 DialogFragment 来展示进度。 ServiceService的生命周期。 Service是运行在后台的android组件，没有用户界面，不能与用户交互，可以运行在自己的进程，也可以运行在其他应用程序的上下文里。 Service随着启动形式的不同，其生命周期稍有差别。当用Context.startService()来启动时，Service的生命周期依次为:oncreate——&gt;onStartCommand——&gt;onDestroy 当用Context.bindService()启动时:onStart——&gt;onBind——&gt;onUnbind——&gt;onDestroy Service有哪些启动方法，有什么区别，怎样停用Service？Service启动方式有两种；一是Context.startService和Context.bindService。 区别是通过startService启动时Service组件和应用程序没多大的联系；当用访问者启动之后，如果访问者不主动关闭，Service就不会关闭，Service组件之间因为没什么关联，所以Service也不能和应用程序进行数据交互。 而通过bindService进行绑定时，应用程序可以通过ServiceConnection进行数据交互。在实现Service时重写的onBind方法中，其返回的对象会传给ServiceConnection对象的onServiceConnected(ComponentName name, IBinder service)中的service参数；也就是说获取了serivce这个参数就得到了Serivce组件返回的值。Context.bindService(Intent intent,ServiceConnection conn,int flag)其中只要与Service连接成功conn就会调用其onServiceConnected方法 停用Service使用Context.stopService 注册Service需要注意什么无论使用哪种启动方法，都需要在xml里注册你的Service，就像这样: 123&lt;service android:name=".packnameName.youServiceName" android:enabled="true" /&gt; service 可以执行耗时操作吗不能，超过20s就会出现ARN Service和Activity在同一个线程吗默认情况下是在同一个主线程中。但可以通过配置android:process=”:remote” 属性让 Service 运行在不同的进程。 Service分为本地服务（LocalService）和远程服务（RemoteService）： 1、本地服务依附在主进程上而不是独立的进程，这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC， 也不需要AIDL。相应bindService会方便很多。主进程被Kill后，服务便会终止。 2、远程服务为独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行， 不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。 按使用方式可以分为以下三种： startService 启动的服务：主要用于启动一个服务执行后台任务，不进行通信。停止服务使用stopService； bindService 启动的服务：该方法启动的服务可以进行通信。停止服务使用unbindService startService 同时也 bindService 启动的服务：停止服务应同时使用stepService与unbindService 参考：http://www.cnblogs.com/linlf03/p/3296323.html Service与Activity怎么实现通信 通过Binder对象。Activity调用bindService (Intent service, ServiceConnection conn, int flags)方法，得到Service对象的一个引用，这样Activity可以直接调用到Service中的方法，如果要主动通知Activity，我们可以利用回调方法。Binder 相关知识参考：http://blog.csdn.net/boyupeng/article/details/47011383 通过广播。Service向Activity发送消息，可以使用广播，当然Activity要注册相应的接收器。比如Service要向多个Activity发送同样的消息的话，用这种方法就更好。 Service里面可以弹出 dialog 或 Toast 吗可以。getApplicationContext() Toast必须在UI主线程上才能正常显示，而在Service中是无法获得Acivity的Context的，在service中想显示出Toast只需将show的消息发送给主线程Looper就可以了。此时便可显示Toast。 1234567Handler handler = new Handler(Looper.getMainLooper()); handler.post(new Runnable() &#123; public void run() &#123; Toast.makeText(getApplicationContext(), "存Service is runing!", Toast.LENGTH_SHORT).show(); &#125; &#125;); Dialog的用法与此类似，但是要多加个权限，在manifest中添加此权限以弹出dialog 12&lt;uses-permission Android:name="android.permission.SYSTEM_ALERT_WINDOW" /&gt;dialog.getWindow().setType((WindowManager.LayoutParams.TYPE_SYSTEM_ALERT)); 什么时候使用Service?比如播放多媒体的时候，用户启动了其他的Activity这个时候程序要在后台继续播放。比如检测SD卡上文件的变化。在或者在后台记录你地理位置的改变等等。 说说Activity、Intent、Service是什么关系一个Activity通常是一个单独的屏幕，每一个Activity都被实现为一个单独的类，这些类都是从Activity基类中继承来的，Activity类显示有视图控件组成的用户接口，并对视图控件的事件做出响应。 Intent的调用是用来进行架构屏幕之间的切换的。Intent是描述应用想要做什么。Intent数据结果中最重要的部分是动作和动作对应的数据，一个动作对应一个动作数据。 Service是运行在后台的代码，不能与用户交互，可以运行在自己的进程，也可以运行在其他应用程序的上下文里。需要通过某一个Activity或其他Context对象来调用。 Activity 跳转到Activity,Activtiy启动Service,Service打开Activity都需要Intent表明跳转的意图，以及传递参数，Intent是这些组件间信号传递的传承者。 怎么在启动一个activity时就启动一个service在activity的onCreate里写startService(xxx);然后this.finish();结束自己.. 这是最简单的方法 可能会有屏幕一闪的现象，如果UI要求严格的话用AIDL把 为什么在Service中创建子线程而不是Activity中这是因为Activity很难对Thread进行控制，当Activity被销毁之后，就没有任何其它的办法可以再重新获取到之前创建的子线程的实例。而且在一个Activity中创建的子线程，另一个Activity无法对其进行操作。但是Service就不同了，所有的Activity都可以与Service进行关联，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。 Service 与 Thread 的区别很多时候，你可能会问，为什么要用 Service，而不用 Thread 呢，因为用 Thread 是很方便的，比起 Service 也方便多了，下面我详细的来解释一下。 1). Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。 2). Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。因此请不要把 Service 理解成线程，它跟线程半毛钱的关系都没有！ 既然这样，那么我们为什么要用 Service 呢？其实这跟 android 的系统机制有关，我们先拿 Thread 来说。Thread 的运行是独立于 Activity 的，也就是说当一个 Activity 被 finish 之后，如果你没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，Thread 也会一直执行。因此这里会出现一个问题：当 Activity 被 finish 之后，你不再持有该 Thread 的引用。另一方面，你没有办法在不同的 Activity 中对同一 Thread 进行控制。 举个例子：如果你的 Thread 需要不停地隔一段时间就要连接服务器做某种同步的话，该 Thread 需要在 Activity 没有start的时候也在运行。这个时候当你 start 一个 Activity 就没有办法在该 Activity 里面控制之前创建的 Thread。因此你便需要创建并启动一个 Service ，在 Service 里面创建、运行并控制该 Thread，这样便解决了该问题（因为任何 Activity 都可以控制同一 Service，而系统也只会创建一个对应 Service 的实例）。 因此你可以把 Service 想象成一种消息服务，而你可以在任何有 Context 的地方调用 Context.startService、Context.stopService、Context.bindService，Context.unbindService，来控制它，你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送 broadcast 来控制它，当然这些都是 Thread 做不到的。 如何保证 Service 在后台不被 kill onStartCommand方法，返回START_STICKY START_STICKY 在运行onStartCommand后service进程被kill后，那将保留在开始状态，但是不保留那些传入的intent。不久后service就会再次尝试重新创建，因为保留在开始状态，在创建 service后将保证调用onstartCommand。如果没有传递任何开始命令给service，那将获取到null的intent。 START_NOT_STICKY 在运行onStartCommand后service进程被kill后，并且没有新的intent传递给它。Service将移出开始状态，并且直到新的明显的方法（startService）调用才重新创建。因为如果没有传递任何未决定的intent那么service是不会启动，也就是期间onstartCommand不会接收到任何null的intent。 START_REDELIVER_INTENT 在运行onStartCommand后service进程被kill后，系统将会再次启动service，并传入最后一个intent给onstartCommand。直到调用stopSelf(int)才停止传递intent。如果在被kill后还有未处理好的intent，那被kill后服务还是会自动启动。因此onstartCommand不会接收到任何null的intent。 提升service优先级 在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。 提升service进程优先级 Android中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进行进程的回收。Android将进程分为6个等级,它们按优先级顺序由高到低依次是: 1.前台进程( FOREGROUND_APP)2.可视进程(VISIBLE_APP )3.次要服务进程(SECONDARY_SERVER )4.后台进程 (HIDDEN_APP)5.内容供应节点(CONTENT_PROVIDER)6.空进程(EMPTY_APP) 当service运行在低内存的环境时，将会kill掉一些存在的进程。因此进程的优先级将会很重要，可以使用startForeground 将service放到前台状态。这样在低内存时被kill的几率会低一些。 onDestroy方法里重启service service +broadcast 方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service； Application加上Persistent属性 监听系统广播判断Service状态 通过系统的一些广播，比如：手机重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的Service是否还存活，别忘记加权限啊。 什么是IntentService？有何优点？IntentService也是一个Service，是Service的子类；IntentService和Service有所不同，通过Looper和Thread来解决标准Service中处理逻辑的阻塞的问题。 优点：Activity的进程，当处理Intent的时候，会产生一个对应的Service,Android的进程处理器现在会尽可能的不kill掉你。 IntentService的使用场景与特点。 IntentService是Service的子类，是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁Service的问题 优点： 一方面不需要自己去new Thread 另一方面不需要考虑在什么时候关闭该Service onStartCommand中回调了onStart，onStart中通过mServiceHandler发送消息到该handler的handleMessage中去。最后handleMessage中回调onHandleIntent(intent)。 IntentService 作用是什么IntentService 是继承于 Service 并处理异步请求的一个类，在IntentService 内有一个工作线程来处理耗时操作，启动 IntentService 的方式和启动传统 Service 一样，同时，当任务执行完后，IntentService 会自动停止，而不需要我们去手动控制。另外，可以启动 IntentService 多次，而每一个耗时操作会以工作队列的方式在 IntentService 的 onHandleIntent 回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个，以此类推。 IntentService 与 Service的异同 直接创建一个默认的工作线程,该线程执行所有的intent传递给onStartCommand()区别于应用程序的主线程。 直接创建一个工作队列,将一个意图传递给你onHandleIntent()的实现,所以我们就永远不必担心多线程。 当请求完成后自己会调用stopSelf()，所以你就不用调用该方法了。 提供的默认实现onBind()返回null，所以也不需要重写这个方法。so easy啊 提供了一个默认实现onStartCommand(),将意图工作队列,然后发送到你onHandleIntent()实现。真是太方便了 ContentProvider参考：http://blog.csdn.net/coder_pig/article/details/47858489 ContentProvider 简介ContentProvider(内容提供者)：为存储和获取数据提供统一的接口。可以在不同的应用程序之间共享数据。Android已经为常见的一些数据提供了默认的ContentProvider ContentProvider 为存储和读取数据提供了统一的接口 使用ContentProvider，应用程序可以实现 app 间数据共享 Android内置的许多数据都是使用ContentProvider形式，供开发者调用的(如视频，音频，图片，通讯录等) 请介绍下ContentProvider是如何实现数据共享的创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Content provider中，前提是有相同数据类型并且有写入Content provider的权限。 ContentProvider使用方法参考：http://blog.csdn.net/juetion/article/details/17481039 Broadcast注册广播有哪几种方式,有什么区别 在应用程序的代码中注册 12registerReceiver（receiver，filter）；// 注册BroadcastReceiverunregisterReceiver（receiver）；// 取消注册BroadcastReceiver 当BroadcastReceiver更新UI，通常会使用这样的方法注册。启动Activity时候注册BroadcastReceiver，Activity不可见时候，取消注册。 在androidmanifest.xml当中注册 12345&lt;receiver&gt; &lt;intent-filter&gt; &lt;action Android:name = "android.intent.action.PICK"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 1)第一种不是常驻型广播，也就是说广播跟随程序的生命周期。 2)第二种是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。 静态注册：在AndroidManifest.xml文件中进行注册，当App退出后，Receiver仍然可以接收到广播并且进行相应的处理 动态注册：在代码中动态注册，当App退出后，也就没办法再接受广播了 一个 app 被杀掉进程后，是否还能收到广播静态注册的常驻型广播接收器还能接收广播。 Android引入广播机制的用意？无序广播、有序广播本地广播和全局广播有什么差别全局广播 BroadcastReceiver 是针对应用间、应用与系统间、应用内部进行通信的一种方式。 本地广播 LocalBroadcastReceiver 仅在自己的应用内发送接收广播，也就是只有自己的应用能收到。因广播数据在本应用范围内传播，不用担心隐私数据泄露的问题。 不用担心别的应用伪造广播，造成安全隐患。 相比在系统内发送全局广播，它更高效。 IntentIntent的使用方法，可以传递哪些数据类型。通过查询Intent/Bundle的API文档，我们可以获知，Intent/Bundle支持传递基本类型的数据和基本类型的数组数据，以及String/CharSequence类型的数据和String/CharSequence类型的数组数据。而对于其它类型的数据貌似无能为力，其实不然，我们可以在Intent/Bundle的API中看到Intent/Bundle还可以传递Parcelable（包裹化，邮包）和Serializable（序列化）类型的数据，以及它们的数组/列表数据。 所以要让非基本类型和非String/CharSequence类型的数据通过Intent/Bundle来进行传输，我们就需要在数据类型中实现Parcelable接口或是Serializable接口。 参考：http://blog.csdn.net/kkk0526/article/details/7214247 介绍一下Intent、IntentFilterContextContext区别 Activity和Service以及Application的Context是不一样的,Activity继承自ContextThemeWraper.其他的继承自ContextWrapper 每一个Activity和Service以及Application的Context都是一个新的ContextImpl对象 getApplication()用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法，getApplicationContext()比getApplication()方法的作用域会更广一些，任何一个Context的实例，只要调用getApplicationContext()方法都可以拿到我们的Application对象。 Activity在创建的时候会new一个ContextImpl对象并在attach方法中关联它，Application和Service也差不多。ContextWrapper的方法内部都是转调ContextImpl的方法 创建对话框传入Application的Context是不可以的 尽管Application、Activity、Service都有自己的ContextImpl，并且每个ContextImpl都有自己的mResources成员，但是由于它们的mResources成员都来自于唯一的ResourcesManager实例，所以它们看似不同的mResources其实都指向的是同一块内存 Context的数量等于Activity的个数 + Service的个数 + 1，这个1为Application Application Context 和 Activity Context 异同Context 的理解HandlerHandler 原理Andriod提供了Handler 和 Looper 来满足线程间的通信。Handler先进先出原则。Looper类用来管理特定线程内对象之间的消息交换(MessageExchange)。 Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的MessageQueue(消息队列)。 Handler: 你可以构造Handler对象来与Looper沟通，以便push新消息到MessageQueue里;或者接收Looper从Message Queue取出)所送来的消息。 Message Queue(消息队列):用来存放线程放入的消息。 线程：UIthread 通常就是main thread，而Android启动程序时会替它建立一个MessageQueue。 参考： Handler、Looper、Message、MessageQueue基础流程分析 Handler消息机制，postDelayed会造成线程阻塞吗？对内存有什么影响？Handler, Looper的理解Handler,Message,Looper异步实现机制与源码分析参考： Android 消息处理机制（Looper、Handler、MessageQueue,Message） Handler有何作用？如何使用之（具体讲需要实现什么function）？Android设计了Handler机制，由Handler来负责与子线程进行通讯，从而让子线程与主线程之间建立起协作的桥梁，使Android的UI更新的问题得到完美的解决。 参考： Handler有何作用？如何使用？ Handler、Thread 和 HandlerThread 的区别Handler 会关联一个单独的线程和消息队列。Handler默认关联主线程(即 UI 线程)，虽然要提供Runnable参数 ，但默认是直接调用Runnable中的run()方法。也就是默认下会在主线程执行，如果在这里面的操作会有阻塞，界面也会卡住。如果要在其他线程执行，可以使用 HandlerThread。 HandlerThread继承于Thread，所以它本质就是个Thread。与普通Thread的差别就在于，主要的作用是建立了一个线程，并且创立了消息队列，有自己的looper,可以让我们在自己的线程中分发和处理消息。 android.os.Handler可以通过Looper对象实例化，并运行于另外的线程中，Android提供了让Handler运行于其它线程的线程实现，也是就HandlerThread。HandlerThread对象start后可以获得其Looper对象，并且使用这个Looper对象实例Handler。 参考： Android中的Thread &amp; HandlerThread &amp; Handler 使用 Handler 时怎么避免引起内存泄漏一旦Handler被声明为内部类，那么可能导致它的外部类不能够被垃圾回收。如果Handler是在其他线程（我们通常成为worker thread）使用Looper或MessageQueue（消息队列），而不是main线程（UI线程），那么就没有这个问题。如果Handler使用Looper或MessageQueue在主线程（main thread），你需要对Handler的声明做如下修改： 声明Handler为static类； 在外部类中实例化一个外部类的WeakReference（弱引用）并且在Handler初始化时传入这个对象给你的Handler； 将所有引用的外部类成员使用WeakReference对象。 12345678910111213141516private static class MyHandler extends Handler &#123; private final WeakReference&lt;HandlerActivity2&gt; mActivity; public MyHandler(HandlerActivity2 activity) &#123; mActivity = new WeakReference&lt;HandlerActivity2&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; System.out.println(msg); if (mActivity.get() == null) &#123; return; &#125; mActivity.get().todo(); &#125; &#125; 当Activity finish后 handler对象还是在Message中排队。 还是会处理消息，这些处理有必要？正常Activitiy finish后，已经没有必要对消息处理，那需要怎么做呢？解决方案也很简单，在Activity onStop或者onDestroy的时候，取消掉该Handler对象的Message和Runnable。通过查看Handler的API，它有几个方法：removeCallbacks(Runnable r)和removeMessages(int what)等。 12345678910/** * 一切都是为了不要让mHandler拖泥带水 */ @Override public void onDestroy() &#123; mHandler.removeMessages(MESSAGE_1); mHandler.removeMessages(MESSAGE_2); mHandler.removeMessages(MESSAGE_3); // ... ... mHandler.removeCallbacks(mRunnable); // ... ... &#125; 参考： Handler内存泄漏分析及解决 AsyncTaskAsyncTask原理参考： 深入理解AsyncTask的工作原理 网络请求是怎么做的异步呢？什么情况下用Handler，什么情况下用AsyncTaskHandler和AsyncTask的区别这俩类都是用来实现异步的，其中AsyncTask的集成度较高，使用简单，Handler则需要手动写Runnable或者Thread的代码；另外，由于AsyncTask内部实现了一个非常简单的线程池，实际上是只适用于轻量级的异步操作的，一般不应该用于网络操作。（感谢网友指正，AsyncTask 通过重写的方式是可以用于长耗时操作的，而我只考虑了直接使用的情况就说它不适合网络操作，是不对的。）我问他Handler和AsyncTask的区别，一方面是因为他说用AsyncTask联网，因此我认为他对AsyncTask并不熟悉；但更重要的是在我问他实现异步的具体手段的时候，他同时提到了Handler和AsyncTask——用这种“混搭”的使用方式来写联网框架，就算不考虑AsyncTask的可用性，也显得非常怪异，这听起来更像是在“列举Android实现异步操作最常用的类”，而非“讲述实现网络异步操作的具体方式”。也就是说，我听了这句话后开始怀疑他封装过联网框架这件事的真实性。但我只是怀疑，并不确定，因此接着问了我想问的。 参考： https://www.zhihu.com/question/30804052 AsyncTask的优缺点？能否同时并发100+AsyncTask呢？参考： AsyncTask到底是什么 线程子线程中更新UI的方法第一种：Handler+Message 第二种： 123456new Handler(context.getMainLooper()).post( new Runnable()&#123; public void run()&#123; //更新UI &#125; &#125;); 第三种： 1234567((Activity)context)runOnUiThread( new Runnable()&#123; public void run()&#123; //更新UI &#125; &#125; ); 多线程 继承 Thread 类 实现 Runnable 接口 HandlerThread Handler AsyncTask Activity.runOnUiThread(Runnable) View.post(Runnable),View.postDelay(Runnable,long) Service Thread IntentService AsyncTask When to use ? Task with no UI, but shouldn’t be too long. Use threads within service for long tasks. - Long task in general.- For tasks in parallel use Multiple threads (traditional mechanisms) - Long task usually with no communication to main thread.(Update)- If communication is required, can use main thread handler or broadcast intents- When callbacks are needed (Intent triggered tasks). - Small task having to communicate with main thread.- For tasks in parallel use multiple instances OR Executor Trigger Call to methodonStartService() Thread start() method Intent Call to method execute() Triggered From (thread) Any thread Any Thread Main Thread (Intent is received on main thread and then worker thread is spawed) Main Thread Runs On (thread) Main Thread Its own thread Separate worker thread Worker thread. However, Main thread methods may be invoked in between to publish progress. Limitations /**Drawbacks** May block main thread - Manual thread management- Code may become difficult to read - Cannot run tasks in parallel.- Multiple intents are queued on the same worker thread. - one instance can only be executed once (hence cannot run in a loop) - Must be created and executed from the Main thread 线程同步 使用 synchronized 关键字创建 synchronized 方法。 使用 synchronized 创建同步代码块。 参考： http://www.itzhai.com/java-based-notebook-thread-synchronization-problem-solving-synchronization-problems-synchronized-block-synchronized-methods.html#2.1%E3%80%81%E4%BD%BF%E7%94%A8synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%9B%E5%BB%BAsynchronized%E6%96%B9%E6%B3%95%EF%BC%9A http://www.juwends.com/tech/android/android-inter-thread-comm.html 进程进程优先级 前台进程：即与用户正在交互的Activity或者Activity用到的Service等，如果系统内存不足时前台进程是最后被杀死的 可见进程：可以是处于暂停状态(onPause)的Activity或者绑定在其上的Service，即被用户可见，但由于失去了焦点而不能与用户交互 服务进程：其中运行着使用startService方法启动的Service，虽然不被用户可见，但是却是用户关心的，例如用户正在非音乐界面听的音乐或者正在非下载页面自己下载的文件等；当系统要空间运行前两者进程时才会被终止 后台进程：其中运行着执行onStop方法而停止的程序，但是却不是用户当前关心的，例如后台挂着的QQ，这样的进程系统一旦没了有内存就首先被杀死 空进程：不包含任何应用程序的程序组件的进程，这样的进程系统是一般不会让他存在的 AIDL 解决了什么问题AIDL (Android Interface Definition Language) 是一种IDL 语言，用于生成可以在 Android 设备上两个进程之间进行进程间通信(interprocess communication, IPC)的代码。如果在一个进程中（例如Activity）要调用另一个进程中（例如 Service, 设置了属性 android:process=”:remote” 后，Service 就会运行在另外一个进程）对象的操作，就可以使用AIDL生成可序列化的参数。 AIDL IPC机制是面向接口的，像COM或Corba一样，但是更加轻量级。它是使用代理类在客户端和实现端传递数据。 AIDL的全称是什么？如何工作？能处理哪些类型的数据ADIL是一种接口定义语言，用于约束两个进程之间的通信规则，供编译器生成代码，实现android设备之间的进程通信。 进程之间的通信信息首先会被转换成AIDL协议消息，然后发送给对方，对方受到AIDL协议消息后在转换成相应的对象。AIDL支持类型包括java基础类型和String，List，Map,CharSequence,如果使用自定类型，必须实现Parcelable接口 Broadcast、Content Provider 和 AIDL的区别和联系这3种都可以实现跨进程的通信，那么从效率，适用范围，安全性等方面来比较的话他们3者之间有什么区别？ Broadcast：用于发送和接收广播！实现信息的发送和接收！ AIDL：用于不同程序间服务的相互调用！实现了一个程序为另一个程序服务的功能！Content Provider:用于将程序的数据库人为地暴露出来！实现一个程序可以对另个程序的数据库进行相对用的操作！ Broadcast,既然是广播，那么它的优点是：注册了这个广播接收器的应用都能够收到广播，范围广。缺点是：速度慢点，而且必须在一定时间内把事情处理完(onReceive执行必须在几秒之内)，否则的话系统给出ANR。 AIDL，是进程间通信用的，类似一种协议吧。优点是：速度快(系统底层直接是共享内存)，性能稳，效率高，一般进程间通信就用它。 Content Provider,因为只是把自己的数据库暴露出去，其他程序都可以来获取数据，数据本身不是实时的，不像前两者,只是起个数据供应作用。一般是某个成熟的应用来暴露自己的数据用的。 你要是为了进程间通信，还是别用这个了，这个又不是实时数据。 进程间传输方式Android进程间通信，Binder机制Android跨进程通讯的方式Android Mashup设计的理解触摸事件View 的触摸事件分发机制基础知识 所有Touch事件都被封装成了MotionEvent对象，包括Touch的位置、时间、历史记录以及第几个手指(多指触摸)等。 事件类型分为ACTION_DOWN, ACTION_UP, ACTION_MOVE, ACTION_POINTER_DOWN, ACTION_POINTER_UP, ACTION_CANCEL，每个事件都是以ACTION_DOWN开始ACTION_UP结束。 对事件的处理包括三类，分别为传递——dispatchTouchEvent()函数、拦截——onInterceptTouchEvent()函数、消费——onTouchEvent()函数和OnTouchListener 传递流程 事件从Activity.dispatchTouchEvent()开始传递，只要没有被停止或拦截，从最上层的View(ViewGroup)开始一直往下(子View)传递。子View可以通过onTouchEvent()对事件进行处理。 事件由父View(ViewGroup)传递给子View，ViewGroup可以通过onInterceptTouchEvent()对事件做拦截，停止其往下传递。 如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到Activity的onTouchEvent()函数。 如果View没有对ACTION_DOWN进行消费，之后的其他事件不会传递过来。 OnTouchListener优先于onTouchEvent()对事件进行消费。 上面的消费即表示相应函数返回值为true。 View不处理事件流程图： View处理事件流程图：View.onTouchEvent() 返回true 拦截事件流程图：ViewGroup.onInterceptTouchEvent() 对MOVE、UP事件进行拦截 参考： Android Touch事件传递机制 事件分发机制 onInterceptTouchEvent()和onTouchEvent()的区别？onInterceptTouchEvent()用于拦截触摸事件。 onTouchEvent()用于处理触摸事件。 view的事件冲突处理ViewView 绘制流程当 Activity 接收到焦点的时候，它会被请求绘制布局，该请求由 Android framework 处理。绘制是从根节点开始，对布局树进行 measure 和 draw。整个 View 树的绘图流程在ViewRoot.java类的 performTraversals() 函数展开，该函数所做 的工作可简单概况为是否需要重新计算视图大小(measure)、是否需要重新安置视图的位置(layout)、以及是否需要重绘(draw)，流程图如下： View的绘制流程是从ViewRoot的performTraversals()方法开始，依次经过measure()，layout()和draw()三个过程才最终将一个View绘制出来。 参考： 公共技术点之 View 绘制流程 Android 绘图机制原理参考： Android中的绘制机制 requertlayout onlayout onDraw drawChild 的区别和联系 requestLayout()方法 ：会导致调用measure()过程 和 layout()过程 。 将会根据标志位判断是否需要ondraw。 onLayout()方法：如果该View是ViewGroup对象，需要实现该方法，对每个子视图进行布局。 调用onDraw()方法绘制视图本身，每个View都需要重载该方法，ViewGroup不需要实现该方法。 drawChild()去重新回调每个子视图的draw()方法。 View 刷新机制在Android的布局体系中，父View负责刷新、布局显示子View；而当子View需要刷新时，则是通知父View来完成。 子View调用invalidate时，首先找到自己父View(View的成员变量mParent记录自己的父View)，然后将AttachInfo中保存的信息告诉父View刷新自己。 在invalidate中，调用父View的invalidateChild，这是一个从第向上回溯的过程，每一层的父View都将自己的显示区域与传入的刷新Rect做交集。 这个向上回溯的过程直到ViewRoot那里结束，由ViewRoot对这个最终的刷新区域做刷新。 参考： Android View刷新机制 invalidata() 和 postInvalidata() 的区别及使用 invalidata() 必须在 UI 线程中调用，所以一般都是配合 Handler 使用。 postInvalidata() 可以在其他线程直接调用。 notifyDataSetChanged和notifyDataSetInvalidated的区别 notifyDataSetInvalidated()，会重绘整个控件（还原到初始状态） notifyDataSetChanged()，重绘当前可见区域 SurfaceView和View的区别是什么？SurfaceView中采用了双缓存技术，在单独的线程中更新界面。而View在UI线程中更新界面。 RemoteView在哪些功能中使用在 AppWidget（桌面小插件）和 Notification（通知栏）中使用。 参考： Android widget 之RemoteView 自定义 View自定义View相关方法 自定义属性的声明和获取 分析需要的自定义属性 在res/values/attrs.xml定义声明 在layout文件中进行使用 在View的构造方法中进行获取 测量onMeasure 布局onLayout(ViewGroup) 绘制onDraw onTouchEvent onInterceptTouchEvent(ViewGroup) 状态的恢复与保存 如何自定义控件有哪些实现自定义控件的方法？自定义控件的实现有三种方式，分别是：组合控件、自绘控件和继承控件。 参考： Android自定义View的三种实现方式 优化自定义 View为了加速你的view，对于频繁调用的方法，需要尽量减少不必要的代码。先从onDraw开始，需要特别注意不应该在这里做内存分配的事情，因为它会导致GC，从而导致卡顿。在初始化或者动画间隙期间做分配内存的动作。不要在动画正在执行的时候做内存分配的事情。 你还需要尽可能的减少onDraw被调用的次数，大多数时候导致onDraw都是因为调用了invalidate().因此请尽量减少调用invaildate()的次数。如果可能的话，尽量调用含有4个参数的invalidate()方法而不是没有参数的invalidate()。没有参数的invalidate会强制重绘整个view。 另外一个非常耗时的操作是请求layout。任何时候执行requestLayout()，会使得Android UI系统去遍历整个View的层级来计算出每一个view的大小。如果找到有冲突的值，它会需要重新计算好几次。另外需要尽量保持View的层级是扁平化的，这样对提高效率很有帮助。 如果你有一个复杂的UI，你应该考虑写一个自定义的ViewGroup来执行他的layout操作。与内置的view不同，自定义的view可以使得程序仅仅测量这一部分，这避免了遍历整个view的层级结构来计算大小。这个PieChart 例子展示了如何继承ViewGroup作为自定义view的一部分。PieChart 有子views，但是它从来不测量它们。而是根据他自身的layout法则，直接设置它们的大小。 自定义view控件以及自定义属性的使用NavigationDrawer，PageAdapter等UI模式的使用和定制Layout 布局Android中常用的五种布局 FrameLayout（框架布局） LinearLayout （线性布局） AbsoluteLayout（绝对布局） RelativeLayout（相对布局） TableLayout（表格布局） LinearLayout和RelativeLayout性能对比 RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。 在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。 最后再思考一下文章开头那个矛盾的问题，为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout。因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。 参考 ： http://www.jianshu.com/p/8a7d059da746 Android中px,sp,dip,dp的区别与联系px: pixel，即像素，1px代表屏幕上的一个物理的像素点。但px单位不被建议使用。因为同样像素大小的图片在不同手机显示的实际大小可能不同。要用到px的情况是需要画1像素表格线或阴影线的时候，如果用其他单位画则会显得模糊。 dip (dp): device independent pixel。dp (dip)是最常用也是最难理解的尺寸单位。与像素密度密切相关。Android系统定义了四种像素密度：低（120dpi）、中（160dpi）、高（240dpi）和超高（320dpi），它们对应的dp到px的系数分别为0.75、1、1.5和2，这个系数乘以dp长度就是像素数。例如界面上有一个长度为“80dp”的图片，那么它在240dpi的手机上实际显示为80x1.5=120px，在320dpi的手机上实际显示为80x2=160px。如果你拿这两部手机放在一起对比，会发现这个图片的物理尺寸“差不多”，这就是使用dp作为单位的效果。 sp: Scale-independent Pixel，即与缩放无关的抽象像素。sp和dp很类似但唯一的区别是，Android系统允许用户自定义文字尺寸大小（小、正常、大、超大等等），当文字尺寸是“正常”时，1sp=1dp=0.00625英寸，而当文字尺寸是“大”或“超大”时，1sp&gt;1dp=0.00625英寸。类似我们在windows里调整字体尺寸以后的效果——窗口大小不变，只有文字大小改变。 asset目录与res目录的区别。res 目录下面有很多文件，例如 drawable,mipmap,raw 等。res 下面除了 raw 文件不会被压缩外，其余文件都会被压缩。同时 res目录下的文件可以通过R 文件访问。 Asset 也是用来存储资源，但是 asset 文件内容只能通过路径或者 AssetManager 读取。 参考： 官方文档 Android屏幕适配动画Android属性动画特性Android 起初有两种动画：Frame Animation（逐帧动画） Tween Animation（补间动画）,但是在用的时候发现这两种动画有时候并不能满足我们的一些需要，所以Google在Androi3.0的时候推出了（Property Animation）属性动画,至于为什么前边的两种动画不能满足我们的需要，请往下看： Frame Animation(逐帧动画) 逐帧动画就是UI设计多张图片组成一个动画，然后将它们组合链接起来进行动画播放。该方式类似于早期电影的制作原理：具体实现方式就不多说了，你只需要让你们的UI出多张图片，然后你顺序的组合就可以（前提是UI给您做图） Tween Animation(补间动画) Tween Animation：是对某个View进行一系列的动画的操作，包括淡入淡出（Alpha），缩放（Scale），平移（Translate），旋转（Rotate）四种模式 Tween Animation(补间动画)的一些缺点： Tween Animation（补间动画）只是针对于View，超脱了View就无法操作了，这句话的意思是：假如我们需要对一个Button，ImageView，LinearLayout或者是其他的继承自View的各种组件进行动画的操作时，Tween Animation是可以帮我们完成我们需要完成的功能的，但是如果我们需要用到对一个非View的对象进行动画操作的话，那么补间动画就没办法实现了。举个例子：比如我们有一个自定义的View，在这个View中有一个Point对象用于管理坐标，然后在onDraw()方法中的坐标就是根据该Pointde坐标值进行绘制的。也就是说，如果我们可以对Point对象进行动画操作，那么整个自定义的View，那么整个自继承View的当前类就都有了动画，但是我们的目的是不想让View有动画，只是对动画中的Point坐标产生动画，这样补间动画就不能满足了。 Tween Animation动画有四种动画操作（移动，缩放，旋转，淡入淡出），但是我们现在有个需求就是将当前View的背景色进行改变呢？抱歉Tween Animation是不能帮助我们实现的。 Tween Animation动画只是改变View的显示效果而已，但是不会真正的去改变View的属性，举个例子：我们现在屏幕的顶部有一个小球，然后通过补间动画让他移动到右下角，然后我们给这个小球添加了点击事件，希望位置移动到右下角的时候点击小球能的放大小球。但是点击事件是绝对不会触发的，原因是补间动画只是将该小球绘制到了屏幕的右下角，实际这个小球还是停在屏幕的顶部，所以你在右下角点击是没有任何反应的。 Property Animatior(属性动画) 属性动画是Android3.0之后引进的，它更改的是动画的实际属性，在Tween Animation(补间动画)中，其改变的是View的绘制效果，真正的View的属性是改变不了的，比如你将你的Button位置移动之后你再次点击Button是没有任何点击效果的，或者是你如何缩放你的Button大小，缩放后的有效的点击区域还是只有你当初初始的Button的大小的点击区域，其位置和大小的属性并没有改变。而在Property Animator(属性动画)中，改变的是动画的实际属性，如Button的缩放，Button的位置和大小属性值都会发生改变。而且Property Animation不止可以应用于View，还可以应用于任何对象，Property Animation只是表示一个值在一段时间内的改变，当值改变时要做什么事情完全是你自己决定的。 Android动画框架实现原理Animation 框架定义了透明度，旋转，缩放和位移几种常见的动画，而且控制的是整个View。实现原理： 每次绘制视图时，View 所在的 ViewGroup 中的 drawChild 函数获取该View 的 Animation 的 Transformation 值，然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵运算完成动画帧，如果动画没有完成，继续调用 invalidate() 函数，启动下次绘制来驱动动画，动画过程中的帧之间间隙时间是绘制函数所消耗的时间，可能会导致动画消耗比较多的CPU资源，最重要的是，动画改变的只是显示，并不能相应事件。 参考： Android动画原理分析 图片缓存图片三级缓存实现？自己设计一个图片加载框架参考： Android中图片的三级缓存 开源选型之Android三大图片缓存原理、特性对比 对 LruCache 的理解参考： 内存缓存LruCache实现原理 Android提供的LruCache类简介 DiskLruCache参考： Android DiskLruCache完全解析，硬盘缓存的最佳方案 缓存算法Bitmap的分析与使用参考： Android 从具体实例分析Bitmap使用时候内存注意点 Android之Bitmap大图加载处理 Loading Large Bitmaps Efficiently Bitmap 压缩123456789101112131415161718192021222324252627282930public static Bitmap create(byte[] bytes, int maxWidth, int maxHeight) &#123; //上面的省略了 option.inJustDecodeBounds = true; BitmapFactory.decodeByteArray(bytes, 0, bytes.length, option); int actualWidth = option.outWidth; int actualHeight = option.outHeight; // 计算出图片应该显示的宽高 int desiredWidth = getResizedDimension(maxWidth, maxHeight, actualWidth, actualHeight); int desiredHeight = getResizedDimension(maxHeight, maxWidth, actualHeight, actualWidth); option.inJustDecodeBounds = false; option.inSampleSize = findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight); Bitmap tempBitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.length, option); // 做缩放 if (tempBitmap != null &amp;&amp; (tempBitmap.getWidth() &gt; desiredWidth || tempBitmap .getHeight() &gt; desiredHeight)) &#123; bitmap = Bitmap.createScaledBitmap(tempBitmap, desiredWidth, desiredHeight, true); tempBitmap.recycle(); &#125; else &#123; bitmap = tempBitmap; &#125; &#125; return bitmap;&#125; 你这么做，decodeByteArray两次不是更占内存吗？😂😂😂 第一次设置inJustDecodeBounds = true 时候是不占内存的，因为返回的是null 一脸不相信我的说：噢，这地方我下去再看看。 吓得我回来了以后赶紧又看了看，还好没有记错，见源码注释 123456/*** If set to true, the decoder will return null (no bitmap), but* the out... fields will still be set, allowing the caller to query* the bitmap without having to allocate the memory for its pixels.*/public boolean inJustDecodeBounds; ARGB_8888格式图片占用内存大小1 byte = 8 bit 8+8+8+8 = 32 32/8 = 4 byte 一个像素就占4byte 参考： 你的 Bitmap 究竟占多大内存 如何判断本地缓存的时候数据需要从网络端获取图片加载机制ListViewListView的优化ListView卡顿原因 在adapter中的getView方法中尽量少使用逻辑 尽最大可能避免GC 滑动的时候不加载图片 将ListView的scrollingCache和animateCache设置为false item的布局层级越少越好 使用ViewHolder ListView 的实现原理参考： Android ListView工作原理完全解析，带你从源码的角度彻底理解 ViewHolder参考： ListView中convertView和ViewHolder的工作原理 ListView 下拉刷新、上拉加载更多实现原理参考： 下拉刷新及滚动到底部加载更多的Listview使用 — 优先使用该开源实现 Android ListView下拉/上拉刷新：设计原理与实现 一个支持下拉上拉的开源库 RecyclerView和ListView的异同 RecyclerView 自带 ViewHolder；而 ListView 则需要自定义。 RecyclerView 支持水平和垂直滚动；而 ListView 只支持垂直滚动。 RecyclerView 提供默认的列表项动画实现，例如：添加、删除和移动列表项动画。 ListView通过AdapterView.OnItemClickListener接口来监听点击事件。而RecyclerView则通过RecyclerView.OnItemTouchListener接口来监听触摸事件。它虽然增加了实现的难度，但是却给予开发人员拦截触摸事件更多的控制权限。 ListView可以设置选择模式，并添加MultiChoiceModeListener；而 RecyclerView 没有该功能。 参考： http://www.tuicool.com/articles/aeeaQ3J http://blog.csdn.net/sanjay_f/article/details/48830311 能否讲讲你用过的adapter？容器SparseArray 和 HashMap 的区别 类 cpu 内存 适用场景 HashMap 增、删、查找速度较快 双倍扩容、不做空间整理，内存使用效率低 数据量较大或内存空间相对宽裕 ArrayMap 增、删、查速度较慢 size大于8扩容时，只增大当前数组大小的一半，做空间收缩整理 数据量小于1000时，速度相对差别不大，可替代HashMap SparseArray 增、查速度较慢，由于延迟删除机制，删速度比ArrayMap快，比HashMap慢 矩阵压缩，大大减少了存储空间，节约内存 避免了key的自动装箱，空间压缩等机制，使得其在key是Integer、Long，且数据量较小场景下性能最优 参考： HashMap、ArrayMap、SparseArray分析比较 内存相关什么情况会导致内存泄漏内存泄漏，简单点说就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。 内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。 资源对象没关闭造成的内存泄漏。对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。 构造Adapter时，没有使用缓存的convertView。 Bitmap对象不在使用时没有调用recycle()释放内存。 长生命周期持有短生命周期对象的引用造成的内存泄漏。试着使用关于application的context来替代和activity相关的context。保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期。 注册没取消造成的内存泄漏。 集合中对象没清理造成的内存泄漏。集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量 (比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它)，那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。 单例造成的内存泄漏。由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏。 匿名内部类和非静态内部类持有外部类的引用造成的内存泄漏。 Handler 造成的内存泄漏。 参考： Android内存泄漏总结 Handler内存泄漏分析及解决 什么情况会导致 OOM 加载对象过大，例如：图片、文件等。 相应资源过多，没有来不及释放。 内存泄漏。 如何避免 OOM： 减少对象的内存占用 使用更加轻量的数据结构。例如，我们可以考虑使用 ArrayMap 或 SparseArray 而不是 HashMap 等传统数据结构。 避免在 Android 里面使用 Enum。 减小 Bitmap 对象的内存占用。缩放比例，解码格式。 使用更小的图片。 内存对象的重复利用 复用系统自带的资源。但需要留意不同系统版本的差异性。 在 ListView 和 GridView 等大量出现重复子组件的视图里对 ConvertView 复用。 Bitmap 对象的复用。在 ListView 和 GridView 等显示大量图片的控件里，需要使用 LRU 的机制来缓存处理好的 Bitmap。 避免在 onDraw 方法里面执行对象的创建。 使用大量字符串拼接操作是，考虑使用 StringBuffer 代替 “+”。 避免对象的内存泄漏 注意 Activity 的泄漏。1）内部类引用导致 Activity 的泄漏。典型的是 Handler 导致的泄漏。为了解决这个问题，可以在UI退出之前，执行remove Handler消息队列中的消息与runnable对象。或者是使用Static + WeakReference的方式来达到断开Handler与Activity之间存在引用关系的目的。2）Activity Context被传递到其他实例中，这可能导致自身被引用而发生泄漏。 考虑使用 Application Context 而不是 Activity Context。对于大部分非必须使用Activity Context的情况（Dialog的Context就必须是Activity Context），我们都可以考虑使用Application Context而不是Activity的Context，这样可以避免不经意的Activity泄露。 注意临时Bitmap对象的及时回收。 注意监听器的注销。 注意缓存容器中的对象泄漏。 注意 WebView 的泄漏。 注意 Cursor 对象是否及时关闭。 参考： Android内存优化之OOM Android 为每个应用程序分配的内存大小是多少Android 程序内存一般限制在16M，也有的是24M 查看每个应用程序最高可用内存12int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); Log.d("TAG", "Max memory is " + maxMemory + "KB"); 123456ActivityManager manager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE); //可用堆内存，单个应用可以使用的最大内存，如果应用内存使用超过这个值，就报OOM int heapgrowthlimit = manager.getMemoryClass(); //进程内存空间分配的最大值，表示的是单个虚拟机可用的最大内存 int heapsize = manager.getLargeMemoryClass(); L.d("heapgrowthlimit = "+heapgrowthlimit+"m"+", heapsize = "+heapsize+""); 1234567//应用程序最大可用内存 int maxMemory = ((int) Runtime.getRuntime().maxMemory())/1024/1024; //应用程序已获得内存 long totalMemory = ((int) Runtime.getRuntime().totalMemory())/1024/1024; //应用程序已获得内存中未使用内存 long freeMemory = ((int) Runtime.getRuntime().freeMemory())/1024/1024; System.out.println("---&gt; maxMemory="+maxMemory+"M,totalMemory="+totalMemory+"M,freeMemory="+freeMemory+"M"); Android中弱引用与软引用的应用场景。预防内存泄漏！擅用WeakReference!所有从类外部传来的对象（特别对于Context,View,Fragmet,Activity对象），如果要将其放进类内部的容器对象或者静态类中引用，请一直用WeakReference包装！比如在TabLayout的源码中，容器对象或者静态类中引用，用WeakReference包装。在TabLayoutOnPageChangeListener中，就为TabLayout做了WeakReference wrap。 ANRANR 定位和修正如果开发机器上出现问题，我们可以通过查看/data/anr/traces.txt即可，最新的ANR信息在最开始部分。 出现 ANR 原因： 应用在5秒内未响应用户的输入事件（如按键或者触摸）。 BroadcastReceiver在10秒内未完成相关的处理。 Service在 20秒内无法处理完成。 主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。 主线程中存在耗时的计算。 主线程中错误的操作，比如Thread.wait或者Thread.sleep等。 修正方法： 使用AsyncTask处理耗时IO操作。 使用Thread或者HandlerThread时，调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。 使用Handler处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。 Activity的onCreate和onResume回调中尽量避免耗时的代码。 BroadcastReceiver中onReceive代码也要尽量减少耗时，建议使用IntentService处理 如何避免： UI线程尽量只做跟UI相关的工作 耗时的操作(比如数据库操作，I/O，连接网络或者别的有可能阻塞UI线程的操作)把它放在单独的线程处理 尽量用Handler来处理UIThread和别的Thread之间的交互 使用 AsyncTask 时：在doInBackground()方法中执行耗时操作；在onPostExecuted()更新UI 。 使用Handler实现异步任务时：在子线程中处理耗时操作，处理完成之后，通过handler.sendMessage()传递处理结果；在handler的handleMessage()方法中更新 UI 或者使用handler.post()方法将消息放到Looper中。 什么是ANR，如何避免ANR。什么是FC？如何避免FC的发生，另外FC发生时如何捕获相应的uncaught exception？性能优化怎么对 Android APP 进行性能优化合理管理内存 节制的使用Service 当界面不可见时释放内存 当内存紧张时释放内存 避免在Bitmap上浪费内存 使用优化过的数据集合 知晓内存的开支情况 谨慎使用抽象编程 尽量避免使用依赖注入框架 使用多个进程 避免内存泄漏 高性能编码优化 避免创建不必要的对象 静态优于抽象 对常量使用static final修饰符 使用增强型for循环语法 多使用系统封装好的API 避免在内部调用Getters/Setters方法 布局优化技巧 重用布局文件 仅在需要时才加载布局 参考： Android 性能优化 性能优化系列总篇 Android APP 内存分析工具有哪些Square 开源库 LeakCanary 参考： 利用 LeakCanary 来检查 Android 内存泄漏 屏幕适配经验参考： Android屏幕适配全攻略 数据存储数据存储，数据持久化的方式有哪些 网络 SharedPreference： 除SQLite数据库外，另一种常用的数据存储方式，其本质就是一个xml文件，常用于存储较简单的参数设置。 SQLite：SQLite是一个轻量级的数据库，支持基本的SQL语法，是常被采用的一种数据存储方式。Android为此数据库提供了一个名为SQLiteDatabase的类，封装了一些操作数据库的api File： 即常说的文件（I/O）存储方法，常用语存储大数量的数据，但是缺点是更新数据将是一件困难的事情。 ContentProvider: Android系统中能实现所有应用程序共享的一种数据存储方式，由于数据通常在各应用间的是互相私密的，所以此存储方式较少使用，但是其又是必不可少的一种存储方式。例如音频，视频，图片和通讯录，一般都可以采用此种方式进行存储。每个Content Provider都会对外提供一个公共的URI（包装成Uri对象），如果应用程序有数据需要共享时，就需要使用Content Provider为这些数据定义一个URI，然后其他的应用程序就通过Content Provider传入这个URI来对数据进行操作。 文件和数据库哪个效率高 数据量非常少，可以使用文件。 如果涉及到查询等操作，并且数据量大，则应该使用数据库。 SharedPreference 实现如何导入外部数据库把数据库存放到 res/raw 目录下，然后在第一次安装启动应用的时间把该数据库拷贝到应用的内部存储空间即 android 系统下的 /data/data/packagename/ 目录下。 谈谈 SQLiteSQLite 数据库升级更新如何保留原来数据在使用数据库之前，基本上会自定义一个类继承自SQLiteOpenHelper。该类的其中一个构造函数形式是这样的（另一个多出来一个DatabaseErrorHandler）： 1234public SQLiteOpenHelper(Context context, String name, CursorFactory factory, int version) &#123; this(context, name, factory, version, null);&#125; 这个构造函数里面的version参数即是我们设定的版本号。第一次使用数据库时传递的这个版本将被系统记录，并调用SQLiteOpenHelper#onCreate()方法进行建表操作。后续传入的版本如果比这个高，则会调用SQLiteOpenHelper#onUpgrade()方法进行升级。 跨越版本的升级 处理好了单个版本的升级，还有一个更加棘手的问题：如果应用程序发布了多个版本，以致出现了三个以上数据库版本， 如何确保所有的用户升级应用后数据库都能用呢？有两种方式： 确定 相邻版本 的差别，从版本1开始依次迭代更新，先执行v1到v2，再v2到v3…… 为 每个版本 确定与现在数据库的差别，为每个case撰写专门的升级代码。 方式一的优点是每次更新数据库的时候只需要在onUpgrade方法的末尾加一段从上个版本升级到新版本的代码，易于理解和维护，缺点是当版本变多之后，多次迭代升级可能需要花费不少时间，增加用户等待； 方式二的优点则是可以保证每个版本的用户都可以在消耗最少的时间升级到最新的数据库而无需做无用的数据多次转存，缺点是强迫开发者记忆所有版本数据库的完整结构，且每次升级时onUpgrade方法都必须全部重写。 以上简单分析了两种方案的优缺点，它们可以说在花费时间上是刚好相反的，至于如何取舍，可能还需要结合具体情况分析。 参考： Android 数据库升级完整解决方案 SQLite 性能优化参考： 性能优化第一篇——数据库性能优化 网络通讯描述一次网络请求的流程 建立TCP连接。在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更高层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。 Web浏览器向服务器发送请求命令。一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。 Web浏览器发送请求头信息。浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。 Web服务器应答。 客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。 Web服务器发送应答头信息。 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。 Web服务器向浏览器发送数据。Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。 Web服务器关闭TCP连接。一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 推送心跳包是TCP包还是UDP包或者HTTP包TCP 参考： Android推送技术研究 android 心跳的分析 Android微信智能心跳方案 Android 代码中实现 WAP 方式联网 通过 APN 列表，获取代码服务器和端口号，如果未设置，则设置成对应运营商的配置。 实现 HtppClient 代理。 CMWAP, CMNET有何区别，网络通讯时是否要特殊处理？如何切换接入点？断点续传首先说多线程，我们要多线程下载一个大文件，就有开启多个线程，多个connection，既然是一个文件分开几个线程来下载，那肯定就是一个线程下载一个部分，不能重复。那么我们这么确定一个线程下载一部分呢，就需要我们在请求的header里面设置。 1conn.setRequestProperty("Range", "bytes="+startPos+"-"+endPos); 这里startPos是指从数据端的哪里开始，endPos是指数据端的结束.根据这样我们就知道，只要多个线程，按顺序指定好开始跟结束，就可以不冲突的下载了。那么我们写文件的时候又该怎么写呢。 1234567byte[] buffer = new byte[1024]; int offset = 0; print("Thread "+this.threadId+" starts to download from position "+startPos); RandomAccessFile threadFile = new RandomAccessFile(this.saveFile,"rwd"); threadFile.seek(startPos); // ... threadFile.write(buffer,0,offset); 这样就可以保证数据的完整性，也不会重复写入了。 那么我们接着说断点续传，断点续传其实也很简单，原理就是使用数据库保存上次每个线程下载的位置和长度。例如我开了两个线程T1，T2来下载一个文件，设文件总大小为1024M，那么就是每个线程下载512M。可是我的下载中断了，那么我下次启动线程的时候（继续下载），是不是应该要知道，我原来下载了多少呢。所以是这样的，我没下载一点，就更新数据库的数据，例如T1，下载了100M,就要实时更新数据库，记录下100M，并且记录下这个线程开始下载位置(startPos)，还有线程负责的长度(512M)。那么我继续下载的时候，就可以像服务器请求startPos+1000M开始的数据了，然后在文件里面也是seek（startPos+1000M）的位置继续下载，就可以实现断点续传了。 参考： android多线程断点续传原理解析 网络的优化参考： 移动端网络优化 HttpClient动态加载插件化，动态加载参考： Android 插件化 动态升级 Android中ClassLoader和java中有什么关系和区别？插件化的原理实际是 Java ClassLoader 的原理，看其他资料前请先看：Java ClassLoader基础 Android 也有自己的 ClassLoader，分为 dalvik.system.DexClassLoader 和 dalvik.system.PathClassLoader，区别在于 PathClassLoader 不能直接从 zip 包中得到 dex，因此只支持直接操作 dex 文件或者已经安装过的 apk（因为安装过的 apk 在 cache 中存在缓存的 dex 文件）。而 DexClassLoader 可以加载外部的 apk、jar 或 dex文件，并且会在指定的 outpath 路径存放其 dex 文件。 参考： Android 插件化 动态升级 注解什么是注解参考： Java Annotation 及几个常用开源项目注解原理简析 使用注解是否会影响性能有些注解是用反射实现的所以影响性能。这类注解库对程序的性能影响并没有想象中的那么夸张，而且类似dagger2这类编译时注解的框架是没有性能影响的。 JNIJNI开发流程WebViewWebView和JSReact Nativejar65k限制 做内部库设计时，最重要的考虑是jar的成本，方法数、体积。Android 傻瓜式分包插件 GitHub：https://github.com/TangXiaoLv/Android-Easy-MultiDex这是一个可自定义哪些类放在 MainDex 中的插件。ReadMe 中详细介绍了在使用 MultiDex 时，为了解决 MainDex 方法数超标的问题，碰到的一个个坑及如何解决，并列出了详细的参考资料，一篇很不错的文章。 参考： U8SDK——支持自动拆分成多个dex文件(MultiDex支持) 其他APP启动过程如何判断应用被强杀在Applicatio中定义一个static常量，赋值为－1，在欢迎界面改为0，如果被强杀，application重新初始化，在父类Activity判断该常量的值。 参考： http://blog.csdn.net/Small_Lee/article/details/51886746 应用被强杀如何解决如果在每一个Activity的onCreate里判断是否被强杀，冗余了，封装到Activity的父类中，如果被强杀，跳转回主界面，如果没有被强杀，执行Activity的初始化操作，给主界面传递intent参数，主界面会调用onNewIntent方法，在onNewIntent跳转到欢迎页面，重新来一遍流程。 简述静默安装的原理，如何在无需root权限的情况下实现静默安装？参考： Android常用代码之APK root权限静默安装 Serializable和Parcelable的区别 都能实现序列化且可用于Intent间的数据传递 Serializable是Java中的序列化接口，使用简单但开销大，序列化和反序列化过程需要大量I/O操作。 Parcelable更适合Android平台，使用麻烦但效率高，主要用在内存序列化上。 Debug和Release状态的不同Toolbar的使用低版本 SDK 如何实现高版本 API自己实现或@TargetApi annotation 在低版本的 SDK 使用高版本的 API 会报错。解决方法是：在高版本 SDK 中使用高版本 API，低版本 SDK 中自己实现。 在使用了高版本 API 的方法前面加一个 @TargetApi(API版本号)。 在代码中判断版本号来控制不同的版本使用不同的代码。 1234567@TargetApi(11) public void text() &#123; if(Build.VERSION.SDK_INT &gt;= 11)&#123; // 使用 API 11 的方法&#125; else &#123; // 使用自己实现的方法&#125; 实现一个单例1234567891011121314151617public class Singleton&#123; private volatile static Singleton mSingleton; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; if(mSingleton == null)&#123;\\A synchronized(Singleton.class)&#123;\\C if(mSingleton == null) mSingleton = new Singleton();\\B &#125; &#125; return mSingleton; &#125;&#125; 如 View 的事件分发，屏幕适配经验，性能优化的经验、Java 线程几种用法等如 AIDL、插件化, 如网络的优化, 如缓存的处理, 如插件化, 如 Service 保活函数调用Trace 怎么玩AlarmManager以及Wakelock的使用算法理解什么是二分算法设计模式Android 中主要用到的几种设计模式Android设计模式参考： http://blog.csdn.net/bboyfeiyu/article/details/44563871 架构设计mvc mvp mvvm 参考： http://www.tianmaying.com/tutorial/AndroidMVC 你怎么看待在android上面应用MVC框架，是否有必要抽象独立于activity的C？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 面试之 Java 篇]]></title>
      <url>http://eddy.wiki/interview-java.html</url>
      <content type="text"><![CDATA[本文出自 Eddy Wiki ，转载请注明出处：http://eddy.wiki/interview-java.html 本文收集整理了 Android 面试中会遇到与 Java 知识相关的简述题。 面向对象Java面向对象的三个特征与含义 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。 多态：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 Java 多态什么是多态 面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。 多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） 实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实 际类型，根据其实际的类型调用其相应的方法。 多态的作用：消除类型之间的耦合关系。 现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。 下面是多态存在的三个必要条件，要求大家做梦时都能背出来！ 多态存在的三个必要条件 一、要有继承； 二、要有重写； 三、父类引用指向子类对象。 多态的好处： 可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。 可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。 接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。 灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。 简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。 Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。 语法知识&amp; 和 &amp;&amp; 的区别&amp;和&amp;&amp;都是可以作为逻辑运算符的，其逻辑运算规则是相同的。 但&amp;作为逻辑运算符时，即使第一个操作符是false，那么它仍然会计算第二个操作符。&amp;&amp;短路与，如果第一个操作符为false，那么它不会再去计算第二个操作符。 用最有效率的方法算出2乘以8等于几?2 &lt;&lt; 3 Java 中的 SoftReference 是什么Java 中的 SoftReference 即对象的软引用。如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。使用软引用能防止内存泄露，增强程序的健壮性。 SoftReference的特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之后，get()方法将返回null 用Map集合缓存软引用的Bitmap对象 1234567891011121314Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();//强引用的Bitmap对象Bitmap bitmap = BitmapFactory.decodeStream(InputStream);//软引用的Bitmap对象SoftReference&lt;Bitmap&gt; bitmapcache = new SoftReference&lt;Bitmap&gt;(bitmap);//添加该对象到Map中使其缓存imageCache.put("1",softRbitmap);// ...//从缓存中取软引用的Bitmap对象SoftReference&lt;Bitmap&gt; bitmapcache_ = imageCache.get("1");//取出Bitmap对象，如果由于内存不足Bitmap被回收，将取得空Bitmap bitmap_ = bitmapcache_.get(); 谈一下对 Java 中的 abstract 的理解abstract(抽象)可以修饰类、方法 如果将一个类设置为abstract，则此类必须被继承使用。此类不可生成对象，必须被继承使用。 abstract可以将子类的共性最大限度的抽取出来，放在父类中，以提高程序的简洁性。 abstract虽然不能生成对象，但是可以声明，作为编译时类型，但不能作为运行时类型。 final和abstract永远不会同时出现。 当abstract用于修饰方法时，此时该方法为抽象方法，此时方法不需要实现，实现留给子类覆盖，子类覆盖该方法之后方法才能够生效。 注意比较：private void print(){};此语句表示方法的空实现。abstract void print(); 此语句表示方法的抽象，无实现。 如果一个类中有一个抽象方法，那么这个类一定为一个抽象类。 反之，如果一个类为抽象类，那么其中可能有非抽象的方法。 如果让一个非抽象类继承一个含抽象方法的抽象类，则编译时会发生错误。因为当一个非抽象类继承一个抽象方法的时候，本着只有一个类中有一个抽象方法，那么这个类必须为抽象类的原则。这个类必须为抽象类，这与此类为非抽象冲突，所以报错。 所以子类的方法必须覆盖父类的抽象方法。方法才能够起作用。 为了实现多态，那么父类必须有定义。而父类并不实现，留给子类去实现。此时可将父类定义成abstract类。如果没有定义抽象的父类，那么编译会出现错误。 abstract 和 static 不能放在一起，否则便会出现错误。（这是因为static不可被覆盖，而abstract为了生效必须被覆盖。） abstract 和 final 不能放在一起，否则便会出现错误。 Overload 和 Override方法的重写(Overriding)和重载(Overloading)是Java多态性的不同表现。重写(Overriding)是父类与子类之间多态性的一种表现，而重载(Overloading)是一个类中多态性的一种表现。 如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。 如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型或有不同的参数次序，则称为方法的重载(Overloading)。不能通过访问权限、返回类型、抛出的异常进行重载. 方法重载规则 被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 方法的重写规则 参数列表必须完全与被重写方法的相同； 返回类型必须完全与被重写方法的返回类型相同； 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 Overload 和 Override 的区别 区别点 方法重载 方法重写 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 访问控制符 public、protected、default、private区别Java访问控制符的含义和使用情况: 修饰符 当前类 同一个包 子类 其他包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 区别： public：可以被所有其他类所访问。 protected：自身，子类及同一个包中类可以访问。 default（默认）：同一包中的类可以访问，声明时没有加修饰符，认为是friendly。 private：只能被自己访问和修改。 接口：接口里的变量都隐式声明为public static final,而接口里的方法默认情况下访问权限为public。 Java 里的常量是怎么定义的 接口(Interface)的中变量默认为static final。 Java 5.0中引入的Enum类型。 在普通类中使用static final修饰变量。 java中abstract,interface,final,static的总结抽象类:abstract 只要有一个或一个以上抽象方法的类,必须用abstract声明为抽象类; 抽象类中可以有具体的实现方法; 抽象类中可以没有抽象方法; 抽象类中的抽象方法必须被它的子类实现,如果子类没有实现,则该子类继续为抽象类 抽象类不能被实例化,但可以由抽象父类指向的子类实例来调用抽象父类中的具体实现方法;通常作为一种默认行为; 要使用抽象类中的方法,必须有一个子类继承于这个抽象类,并实现抽象类中的抽象方法,通过子类的实例去调用; 接口:interface 接口中可以有成员变量,且接口中的成员变量必须定义初始化; 接口中的成员方法只能是方法原型,不能有方法主体; 接口的成员变量和成员方法只能public(或缺省不写),效果一样,都是public 实现接口的类必须全部实现接口中的方法(父类的实现也算,一般有通过基类实现接口中个异性不大的方法来做为适配器的做法) 关键字:final 可用于修饰:成员变量,非抽象类(不能与abstract同时出现),非抽象的成员方法,以及方法参数 final方法:不能被子类的方法重写,但可以被继承; final类:表示该类不能被继承,没有子类;final类中的方法也无法被继承. final变量:表示常量,只能赋值一次,赋值后不能被修改.final变量必须定义初始化; final不能用于修饰构造方法; final参数:只能使用该参数,不能修改该参数的值; 关键字:static 可以修饰成员变量和成员方法,但不能修饰类以及构造方法; 被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享 static变量和static方法一般是通过类名直接访问,但也可以通过类的实例来访问(不推荐这种访问方式) static变量和static方法同样适应java访问修饰符.用public修饰的static变量和static方法,在任何地方都可以通过类名直接来访问,但用private修饰的static变量和static方法,只能在声明的本类方法及静态块中访问,但不能用this访问,因为this属于非静态变量. static和final同时使用 static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！ 对于变量，表示一旦给值就不可修改，并且通过类名可以访问。 对于方法，表示不可覆盖，并且可以通过类名直接访问。 switch 能否用 String 做参数？从 Java 7开始 switch 就能使用 String 做为参数。 在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。 Object有哪些公用方法？1．clone方法 保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。 主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法。 2．getClass方法 final方法，获得运行时类型。 3．toString方法 该方法用得比较多，一般子类都有覆盖。 4．finalize方法 该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。 5．equals方法 该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。 6．hashCode方法 该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。 一般必须满足obj1.equals(obj2)==true。可以推出obj1.hashCode()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。 如果不重写hashCode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。 7．wait方法 wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。 调用该方法后当前线程进入睡眠状态，直到以下事件发生。 （1）其他线程调用了该对象的notify方法。 （2）其他线程调用了该对象的notifyAll方法。 （3）其他线程调用了interrupt中断该线程。 （4）时间间隔到了。 此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。 8．notify方法 该方法唤醒在该对象上等待的某个线程。 9．notifyAll方法 该方法唤醒在该对象上等待的所有线程。 foreach与正常for循环效率对比。直接for循环效率最高，其次是迭代器和 ForEach操作。作为语法糖，其实 ForEach 编译成 字节码之后，使用的是迭代器实现的，反编译后，testForEach方法如下： 123456public static void testForEach(List list) &#123; for (Iterator iterator = list.iterator(); iterator.hasNext();) &#123; Object t = iterator.next(); Object obj = t; &#125; &#125; 可以看到，只比迭代器遍历多了生成中间变量这一步，因为性能也略微下降了一些。 基本数据类型基本数据类型 int char long 等各占多少字节 类型 位数 字节数 boolean 8（数组）或32（单个变量） 1（数组）或4（单个变量） byte 8 1 short 16 2 int 32 4 long 64 8 float 32 4 double 64 8 char 16 2 PS：单个的 boolean 类型变量在编译的时候是使用的 int 类型。而对于 boolean 类型的数组时，在编译的时候是作为 byte。 int 和 integer 的区别 int是基本的数据类型； Integer是int的封装类； int和Integer都可以表示某一个数值； int和Integer不能够互用，因为他们两种不同的数据类型； String是否可以继承String类?不能，因为 String 为 final 类。 swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上? switch语句中的表达式只能是byte，short，char ，int以及枚举（enum），所以当表达式是byte的时候可以隐含转换为int类型，而long字节比int字节多，不能隐式转化为int类型，所以switch语句可以用在byte上而不可以用在long上。 由于在JDK7.0中引入了新特性，所以switch语句可以接收一个String类型的值，switch语句可以作用在String上。 常量final string str=“ab”可不可以变成”abd”，为什么？不能，因为使用 final 修饰的变量不可改变。 StringBuffer的作用？StringBuffer类和String一样，也用来代表字符串，只是由于StringBuffer的内部实现方式和String不同，所以StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。 所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些。 String StringBuffer StringBuilder 的区别三者在执行速度方面的比较：StringBuilder &gt; StringBuffer &gt; String String 字符串常量，不可变 StringBuffer 字符串变量（线程安全） StringBuilder 字符串变量（非线程安全） 和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。 由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM 的 GC 就会开始工作，那速度是一定会相当慢的。 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的： 12String S1 = “This is only a” + “ simple” + “ test”;StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”); 你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个 String S1 = “This is only a” + “ simple” + “test”; 其实就是： String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如： 1234String S2 = “This is only a”; String S3 = “ simple”;String S4 = “ test”;String S1 = S2 +S3 + S4; 这时候 JVM 会规规矩矩的按照原来的方式去做。在大部分情况下 StringBuffer &gt; String。 StringBuffer Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。 可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。 StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。 例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。 在大部分情况下 StringBuilder &gt; StringBuffer java.lang.StringBuilder java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同 String s = new String(“abc”); new了几个对象两个 数组有没有length()这个方法? String有没有length()这个方法？ 数组中没有length()这个方法，但是数组中有length这个属性。用来表示数组的长度。 String中有length()这个方法。用来得到字符串的长度。 String 源码分析参考： String源码分析 内部类Static Inner Class 和 Inner Class 的不同 静态内部类不持有外部类的引用；非静态内部类持有外部类的引用。 静态内部类可以有静态成员（方法、属性），而非静态内部类则不能有静态成员（方法、属性）。 静态内部类只能访问外部类的静态成员和静态方法，而非静态内部类则可以访问外部类的所以成员（方法、属性）。 实例化一个静态内部类不依赖于外部类的实例，直接实例化内部类对象；实例化一个非静态内部类依赖于外部类的实例，通过外部类的实例生成内部类的实例。 调用静态内部类的方法或静态变量，直接通过类名调用。 内部类机制为什么内部类拥有外部类的所有元素的访问权？当某个外围类对象创建一个内部连对象时，内部类对象必定会捕获一个指向那个外围类对象的引用。内部类对象只能在与其外部类对象关联的情况下才能被创建（在内部类非static时），构建内部类需要一个外部类的引用，内部类正是利用这个引用去访问外部类的。 内部类的种类按照内部类所在的位置不同，内部类可以分为以下几种： 成员内部类 方法内部类 匿名内部类 静态内部类 内部类的作用？ 内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。 创建内部类对象的时刻并不依赖与外围类对象的创建。 内部类并没有令人迷惑的“is-a”关系，它就是一个独立的实体。 内部类提供了更好的封装，除了外围类，其他类都不能访问。 静态内部类、内部类、匿名内部类，为什么内部类会持有外部类的引用？持有的引用是this？还是其它？静态内部类：使用static修饰的内部类 匿名内部类：使用new生成的内部类 因为内部类的产生依赖于外部类，持有的引用是类名.this。 继承父类的静态方法能否被子类重写不能。 父类的静态方法是不能被子类重写的，其实重写只能适用于实例方法，不能用于静态方法，对于上面这种静态方法而言，我们应该称之为隐藏。 Java静态方法形式上可以重写，但从本质上来说不是Java的重写。因为静态方法只与类相关，不与具体实现相关。声明的是什么类，则引用相应类的静态方法(本来静态无需声明，可以直接引用)。并且static方法不是后期绑定的，它在编译期就绑定了。换句话说，这个方法不会进行多态的判断，只与声明的类有关。 抽象类和接口抽象类总结规定 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用static修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 接口与类的区别 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多重继承。 接口特性 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 抽象类和接口的区别 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类中可以有静态代码块和静态方法。注意：Java 8的新特性允许接口中存在静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 接口中不能有构造函数和main方法；而抽象类中可以有。 默认的方法实现。抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现。 实现。使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现。 构造器。抽象类可以有构造器。接口不能有构造器。 与正常Java类的区别。除了你不能实例化抽象类之外，它和普通Java类没有任何区 接口是完全不同的类型 访问修饰符。抽象方法可以有public、protected和default这些修饰符 接口方法默认修饰符是public。你不可以使用其它修饰符。 main方法。抽象方法可以有main方法并且我们可以运行它。接口没有main方法，因此我们不能运行它。 多继承。抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。 速度。抽象类比接口速度要快。接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。 添加新方法。如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。如果你往接口中添加方法，那么你必须改变实现该接口的类。 语法层面上的区别 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法； 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的； 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法； 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 设计层面上的区别 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。 接口的意义 提供一个规范，要求类必须实现指定的方法。 解决 Java 中的单继承问题，可以用接口来实现多继承的功能，简单化多重继承中继承树的复杂程度。 增强程序的扩展性。 抽象类的意义为其子类提供一个公共的类型、封装子类中的重复内容、定义抽象方法，子类虽然有不同的实现，但是定义是一致的。 接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concreteclass)? 接口可以继承接口。但是要使用extends，而不是用implements。 抽象类可以实现接口。比如java.util中的AbstractCollection类就是实现的Collection接口。 抽象类可以继承实体类。 下面这段执行无误的代码说明的所有的问题: 123456789101112131415interface MyInterface &#123;&#125;interface AnotherInterface extends MyInterface &#123;&#125;class EntityClass &#123;&#125;abstract class AbstractClass extends EntityClass implements MyInterface &#123;&#125; 接口的继承一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。 下面的Sports接口被Hockey和Football接口继承： 1234567891011121314151617181920212223// 文件名: Sports.javapublic interface Sports&#123; public void setHomeTeam(String name); public void setVisitingTeam(String name);&#125; // 文件名: Football.javapublic interface Football extends Sports&#123; public void homeTeamScored(int points); public void visitingTeamScored(int points); public void endOfQuarter(int quarter);&#125; // 文件名: Hockey.javapublic interface Hockey extends Sports&#123; public void homeGoalScored(); public void visitingGoalScored(); public void endOfPeriod(int period); public void overtimePeriod(int ot);&#125; Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。 相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。 接口的多重继承 在Java中，类的多重继承是不合法，但接口允许多重继承。在接口的多重继承中extends关键字只需要使用一次，在其后跟着继承接口。如下所示： 1public interface Hockey extends Sports, Event 以上的程序片段是合法定义的子接口，与类不同的是，接口允许多重继承，而 Sports及 Event 可能定义或是继承相同的方法 abstract的method是否可同时是static，是否可同时是native，是否可同时时final，是否可同时是synchronized?都不行。 abstract的method不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！ native方法表示该方法要用另外一种依赖平台的编辑语言实现的，不存在者被子类实现的问题，所以，他也不能是抽象的，不能与abstract混用。 关于synchronized中avstract合用的问题，我觉得也不行，因为我觉得 synchronized应该是作用在一个具体的方法上才有意义。而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法 上无法确定this是什么。 final类使用 final 修饰符的用处？当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。 在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。 参考：http://www.cnblogs.com/dolphin0520/p/3736238.html finally final finalize的作用？final用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。 finally是异常处理语句结构的一部分，表示总是执行。 finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。 容器Java 集合框架 参考： Java集合框架 列举 Java 的集合和它们的继承关系 Collection包结构，与Collections的区别。Collection是一个接口，它是Set、List等容器的父接口； Collections是一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。 List, Set, Map是否继承自Collection接口?List和Set是，Map不是。 Set和List的区别 Set接口存储的是无序的、不重复的数据。 List接口存储的是有序的、可以重复的数据。 Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 ，实现类有HashSet、TreeSet。 List查找元素效率高，插入删除效率低，因为会引起其他元素位置改变，实现类有ArrayList、LinkedList、Vector。List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。 hashCode方法的作用对于包含容器类型的程序设计语言来说，基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。 为什么这么说呢？考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在） 也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。下面这段代码是java.util.HashMap的中put方法的具体实现： 12345678910111213141516171819public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; put方法是用来向HashMap中添加新的元素，从put方法的具体实现可知，会先调用hashCode方法得到该元素的hashCode值，然后查看table中是否存在该hashCode值，如果存在则调用equals方法重新确定是否存在该元素，如果存在，则更新value值，否则将新的元素添加到HashMap中。从这里可以看出，hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。 hashCode返回的就是对象的存储地址，事实上这种看法是不全面的，确实有些JVM在实现时是直接返回对象的存储地址，但是大多时候并不是这样，只能说可能存储地址有一定关联。 因此有人会说，可以直接根据hashcode值判断两个对象是否相等吗？肯定是不可以的，因为不同的对象可能会生成相同的hashcode值。虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。 如果equals方法得到的结果为true，则两个对象的hashcode值必定相等； 如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同； 如果两个对象的hashcode值不等，则equals方法得到的结果必定为false； 如果两个对象的hashcode值相等，则equals方法得到的结果未知。 当x.equals(y)等于true时，x.hashCode()与y.hashCode()可以不相等，这句话对不对?如果equals方法得到的结果为true，则两个对象的hashcode值必定相等； Java 中 == 和 equals 和 hashCode 的区别 ‘==’是用来比较两个变量（基本类型和对象类型）的值是否相等的， 如果两个变量是基本类型的，那很容易，直接比较值就可以了。如果两个变量是对象类型的，那么它还是比较值，只是它比较的是这两个对象在栈中的引用（即地址）。 对象是放在堆中的，栈中存放的是对象的引用（地址）。由此可见’==’是对栈中的值进行比较的。如果要比较堆中对象的内容是否相同，那么就要重写equals方法了。 Object类中的equals方法就是用’==’来比较的，所以如果没有重写equals方法，equals和==是等价的。 通常我们会重写equals方法，让equals比较两个对象的内容，而不是比较对象的引用（地址）因为往往我们觉得比较对象的内容是否相同比比较对象的引用（地址）更有意义。 Object类中的hashCode是返回对象在内存中地址转换成的一个int值（可以就当做地址看）。所以如果没有重写hashCode方法，任何对象的hashCode都是不相等的。通常在集合类的时候需要重写hashCode方法和equals方法，因为如果需要给集合类（比如：HashSet）添加对象，那么在添加之前需要查看给集合里是否已经有了该对象，比较好的方式就是用hashCode。 注意的是String、Integer、Boolean、Double等这些类都重写了equals和hashCode方法，这两个方法是根据对象的内容来比较和计算hashCode的。（详细可以查看jdk下的String.java源代码），所以只要对象的基本类型值相同，那么hashcode就一定相同。 equals()相等的两个对象，hashcode()一般是相等的，最好在重写equals()方法时，重写hashcode()方法； equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。换句话说，equals()方法不相等的两个对象，hashcode()有可能相等。 反过来：hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。在object类中，hashcode()方法是本地方法，返回的是对象的引用（地址值），而object类中的equals()方法比较的也是两个对象的引用（地址值），如果equals()相等，说明两个对象地址值也相等，当然hashcode()也就相等了。 有许多人学了很长时间的Java，但一直不明白hashCode方法的作用，我来解释一下吧。首先，想要明白hashCode的作用，你必须要先知道Java中的集合。 总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。你知道它们的区别吗？前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。 那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。 于是，Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。如果详细讲解哈希算法，那需要更多的文章篇幅，我在这里就不介绍了。初学者可以这样理解，hashCode方法实际上返回的就是对象存储的物理地址（实际可能并不是）。 这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。 所以，Java对于eqauls方法和hashCode方法是这样规定的： 如果两个对象相同，那么它们的hashCode值一定要相同； 如果两个对象的hashCode相同，它们并不一定相同。 上面说的对象相同指的是用eqauls方法比较。 你当然可以不按要求去做了，但你会发现，相同的对象可以出现在Set集合中。同时，增加新元素的效率会大大下降。 Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?使用equals()区分。 ==是用来判断两者是否是同一对象（同一事物），而equals是用来判断是否引用同一个对象。 set里面存放的是对象的引用，所以当两个元素只要满足了equals()时就已经指向同一个对象，也就出现了重复元素。所以应该用equals()来判断。 多线程环境中安全使用集合API在集合API中，最初设计的Vector和Hashtable是多线程安全的。例如：对于Vector来说，用来添加和删除元素的方法是同步的。如果只有一个线程与Vector的实例交互，那么，要求获取和释放对象锁便是一种浪费，另外在不必要的时候如果滥用同步化，也有可能会带来死锁。因此，对于更改集合内容的方法，没有一个是同步化的。集合本质上是非多线程安全的，当多个线程与集合交互时，为了使它多线程安全，必须采取额外的措施。 在Collections类中有多个静态方法，它们可以获取通过同步方法封装非同步集合而得到的集合： 1234567891011public static Collection synchronizedCollention(Collection c)public static List synchronizedList(list l)public static Map synchronizedMap(Map m)public static Set synchronizedSet(Set s)public static SortedMap synchronizedSortedMap(SortedMap sm)public static SortedSet synchronizedSortedSet(SortedSet ss) 这些方法基本上返回具有同步集合方法版本的新类。比如，为了创建多线程安全且由ArrayList支持的List，可以使用如下代码： 1List list = Collection.synchronizedList(new ArrayList()); 注意，ArrayList实例马上封装起来，不存在对未同步化ArrayList的直接引用（即直接封装匿名实例）。这是一种最安全的途径。如果另一个线程要直接引用ArrayList实例，它可以执行非同步修改。 下面给出一段多线程中安全遍历集合元素的示例。我们使用Iterator逐个扫描List中的元素，在多线程环境中，当遍历当前集合中的元素时，一般希望阻止其他线程添加或删除元素。安全遍历的实现方法如下： 12345678910111213141516171819202122232425import java.util.*; public class SafeCollectionIteration extends Object &#123; public static void main(String[] args) &#123; //为了安全起见，仅使用同步列表的一个引用，这样可以确保控制了所有访问 //集合必须同步化，这里是一个List List wordList = Collections.synchronizedList(new ArrayList()); //wordList中的add方法是同步方法，会获取wordList实例的对象锁 wordList.add("Iterators"); wordList.add("require"); wordList.add("special"); wordList.add("handling"); //获取wordList实例的对象锁， //迭代时，阻塞其他线程调用add或remove等方法修改元素 synchronized ( wordList ) &#123; Iterator iter = wordList.iterator(); while ( iter.hasNext() ) &#123; String s = (String) iter.next(); System.out.println("found string: " + s + ", length=" +s.length()); &#125; &#125; &#125; &#125; 这里需要注意的是：在Java语言中，大部分的线程安全类都是相对线程安全的，它能保证对这个对象单独的操作时线程安全的，我们在调用的时候不需要额外的保障措施，但是对于一些特定的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。例如Vector、HashTable、Collections的synchronizedXxxx（）方法包装的集合等。 集合类的源码分析参考： ArrayList源码剖析 LinkedList源码剖析 Vector源码剖析 HashMap源码剖析 LinkedHashMap源码剖析 HashTable源码剖析 HashMap的底层实现参考： https://github.com/GeniusVJR/LearningNotes/blob/master/Part2/JavaSE/HashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.md HashMap 的实现原理 HashMap概述：HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 HashMap的数据结构：在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。 从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。 容器类之间的区别HashMap 和 HashTable 的区别 继承不同。 12public class Hashtable extends Dictionary implements Mappublic class HashMap extends AbstractMap implements Map Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。 Hashtable中，key和value都不允许出现null值。在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。 两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 ArrayMap 和 HashMap 的区别 存储方式不一样。ArrayMap 使用两个数组来存储，HashMap 则使用一个链表数组来存储。 扩容处理方法不一样。ArrayMap 使用 System.arraycopy() copy 数组，而 HashMap 使用 new HashMapEntry 重新创建数组。 ArrayMap 提供了数组收缩的功能，在clear或remove后，会重新收缩数组，节省空间。 ArrayMap 采用二分法查找。 ArrayList Vector LinkedList 三者的区别 三者都实现了List 接口；但 LinkedList 还实现了 Queue 接口。 ArrayList 和 Vector 使用数组存储数据；LinkedList 使用双向链表存储数据。 ArrayList 和 LinkedList 是非线程安全的；Vector 是线程安全的。 ArrayList 数据增长时空间增长50%；而 Vector 是增长1倍； LinkedList 在添加、删除元素时具有更好的性能，但读取性能要低一些。 LinkedList 与 ArrayList 最大的区别是 LinkedList 更加灵活，并且部分方法的效率比 ArrayList 对应方法的效率要高很多，对于数据频繁出入的情况下，并且要求操作要足够灵活，建议使用 LinkedList；对于数组变动不大，主要是用来查询的情况下，可以使用 ArrayList。 TreeMap、HashMap、LinkedHashMap的区别。Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了)，但允许值重复。 Hashmap 是一个最常用的Map，它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null。HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。 Hashtable与 HashMap类似,它继承自Dictionary类，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了 Hashtable在写入时会比较慢。 LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。 TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。 一般情况下，我们用的最多的是HashMap。HashMap里面存入的键值对在取出的时候是随机的，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。 TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。 LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现,它还可以按读取顺序来排列，像连接池中可以应用。 参考： HashMap,LinkedHashMap,TreeMap的区别 Map、Set、List、Queue、Stack的特点与用法。Collection 是对象集合 Collection 有两个子接口 List 和 Set List 可以通过下标 (1,2..) 来取得值，值可以重复 而 Set 只能通过游标来取值，并且值是不能重复的 ArrayList ， Vector ， LinkedList 是 List 的实现类 ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的 LinkedList 是线程不安全的，底层是由链表实现的 Map 是键值对集合 HashTable 和 HashMap 是 Map 的实现类 HashTable 是线程安全的，不能存储 null 值 HashMap 不是线程安全的，可以存储 null 值 Stack类：继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。 Queue接口：提供了几个基本方法，offer、poll、peek等。已知实现类有LinkedList、PriorityQueue等。 参考： Map、Set、List、Queue、Stack的特点与用法 内存相关知识参考： Android内存泄漏总结 Java 内存分配策略Java 程序运行时的内存分配策略有三种，分别是静态分配、栈式分配和堆式分配，对应的，三种存储策略使用的内存空间主要分别是静态存储区（也称方法区）、栈区和堆区。 静态存储区（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。 栈区 ：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 堆区 ： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。 栈与堆的区别在方法体内定义的（局部变量）一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配的。当在一段方法块中定义一个变量时，Java 就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给它的内存空间也将被释放掉，该内存空间可以被重新使用。 堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组。在堆中分配的内存，将由 Java 垃圾回收器来自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，这个特殊的变量就是我们上面说的引用变量。我们可以通过这个引用变量来访问堆中的对象或者数组。 举个例子: 1234567891011public class Sample &#123; int s1 = 0; Sample mSample1 = new Sample(); public void method() &#123; int s2 = 1; Sample mSample2 = new Sample(); &#125;&#125;Sample mSample3 = new Sample(); Sample 类的局部变量 s2 和引用变量 mSample2 都是存在于栈中，但 mSample2 指向的对象是存在于堆上的。mSample3 指向的对象实体存放在堆上，包括这个对象的所有成员变量 s1 和 mSample1，而它自己存在于栈中。 结论： 局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中。因为它们属于方法中的变量，生命周期随方法而结束。 成员变量全部存储于堆中（包括基本数据类型，引用和引用的对象实体）。因为它们属于类，类对象终究是要被new出来使用的。 heap(堆) 和 stack(栈) 有什么区别。Java 的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量（,int, short, long, byte, float, double, boolean, char）和对象句柄。栈有一个很重要的特殊性，就是存在栈中的数据可以共享。 Stack存取速度仅次于寄存器，存储效率比heap高，可共享存储数据，但是其中数据的大小和生存期必须在运行前确定。 Heap是运行时可动态分配的数据区，从速度看比Stack慢，Heap里面的数据不共享，大小和生存期都可以在运行时再确定。 Java是如何管理内存Java的内存管理就是对象的分配和释放问题。在 Java 中，程序员需要通过关键字 new 为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间。另外，对象的释放是由 GC 决定和执行的。在 Java 中，内存的分配是由程序完成的，而内存的释放是由 GC 完成的，这种收支两条线的方法确实简化了程序员的工作。但同时，它也加重了JVM的工作。这也是 Java 程序运行速度较慢的原因之一。因为，GC 为了能够正确释放对象，GC 必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC 都需要进行监控。监视对象状态是为了更加准确地、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。 为了更好理解 GC 的工作原理，我们可以将对象考虑为有向图的顶点，将引用关系考虑为图的有向边，有向边从引用者指向被引对象。另外，每个线程对象可以作为一个图的起始顶点，例如大多程序从 main 进程开始执行，那么该图就是以 main 进程顶点开始的一棵根树。在这个有向图中，根顶点可达的对象都是有效对象，GC将不回收这些对象。如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被 GC 回收。以下，我们举一个例子说明如何用有向图表示内存管理。对于程序的每一个时刻，我们都有一个有向图表示JVM的内存分配情况。以下右图，就是左边程序运行到第6行的示意图。 Java使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的。这种方式的优点是管理内存的精度很高，但是效率较低。另外一种常用的内存管理技术是使用计数器，例如COM模型采用计数器方式管理构件，它与有向图相比，精度行低(很难处理循环引用的问题)，但执行效率很高。 GC引用计数法循环引用会发生什么情况什么是Java中的内存泄露在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。 在C++中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于C++中没有GC，这些内存将永远收不回来。在Java中，这些不可达的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。 通过分析，我们得知，对于C++，程序员需要自己管理边和顶点，而对于Java程序员只需要管理边就可以了(不需要管理顶点的释放)。通过这种方式，Java提高了编程的效率。 因此，通过以上分析，我们知道在Java中也有内存泄漏，但范围比C++要小一些。因为Java从语言上保证，任何对象都是可达的，所有的不可达对象都由GC管理。 对于程序员来说，GC基本是透明的，不可见的。虽然，我们只有几个函数可以访问GC，例如运行GC的函数System.gc()，但是根据Java语言规范定义， 该函数不保证JVM的垃圾收集器一定会执行。因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC的执行影响应用程序的性能，例如对于基于Web的实时系统，如网络游戏等，用户不希望GC突然中断应用程序执行而进行垃圾回收，那么我们需要调整GC的参数，让GC能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun提供的HotSpot JVM就支持这一特性。 同样给出一个 Java 内存泄漏的典型例子， 123456Vector v = new Vector(10);for (int i = 1; i &lt; 100; i++) &#123; Object o = new Object(); v.add(o); o = null; &#125; 在这个例子中，我们循环申请Object对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。 详解Java中的内存泄漏Java内存回收机制 不论哪种语言的内存分配方式，都需要返回所分配内存的真实地址，也就是返回一个指针到内存块的首地址。Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，这样也可以消除引用循环的问题。在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，以下再没有调用过，另一个是给对象赋予了新值，这样重新分配了内存空间。 Java内存泄漏引起的原因 内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。 Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。具体主要有如下几大类： 静态集合类引起内存泄漏。 像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。 例如： 1234567Static Vector v = new Vector(10);for (int i = 1; i&lt;100; i++)&#123; Object o = new Object(); v.add(o); o = null;&#125; 在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。 当集合里面的对象属性被修改后，再调用remove()方法时不起作用。例如： 12345678910111213141516171819public static void main(String[] args) &#123; Set&lt;Person&gt; set = new HashSet&lt;Person&gt;(); Person p1 = new Person("唐僧","pwd1",25); Person p2 = new Person("孙悟空","pwd2",26); Person p3 = new Person("猪八戒","pwd3",27); set.add(p1); set.add(p2); set.add(p3); System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:3 个元素! p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变 set.remove(p3); //此时remove不掉，造成内存泄漏 set.add(p3); //重新添加，居然添加成功 System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:4 个元素! for (Person person : set) &#123; System.out.println(person); &#125;&#125; 监听器 在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。 各种连接 比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。 内部类和外部模块的引用 内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：public void registerMsg(Object b);这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。 单例模式 不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏，考虑下面的例子： 12345678910111213141516171819202122class A &#123; public A()&#123; B.getInstance().setA(this); &#125; // ...&#125;//B类采用单例模式class B &#123; private A a; private static B instance=new B(); public B()&#123; &#125; public static B getInstance()&#123; return instance; &#125; public void setA(A a)&#123; this.a=a; &#125; // ...&#125; 显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况。 Java内存回收机制，GC 垃圾回收机制，垃圾回收的优点和原理，并说出3种回收机制。 java语言最显著的特点就是引入了垃圾回收机制，它使java程序员在编写程序时不再考虑内存管理的问题。 由于有这个垃圾回收机制，java中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。 垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。 垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。 程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。 垃圾回收机制有：分代复制垃圾回收、标记垃圾回收、增量垃圾回收。 垃圾回收算法 引用计数法：缺点是无法处理循环引用问题 标记-清除法：标记所有从根结点开始的可达对象，缺点是会造成内存空间不连续，不连续的内存空间的工作效率低于连续的内存空间，不容易分配内存 标记－压缩算法：标记－清除的改进，清除未标记的对象时还将所有的存活对象压缩到内存的一端，之后，清理边界所有空间既避免碎片产生，又不需要两块同样大小的内存快，性价比高。适用于老年代。 复制算法：将内存空间分成两块，每次将正在使用的内存中存活对象复制到未使用的内存块中，之后清除正在使用的内存块。算法效率高，但是代价是系统内存折半。适用于新生代(存活对象少，垃圾对象多) 分代 Java 虚拟机的特性Java 语言的一个非常重要的特点就是与平台的无关性，而 Java 虚拟机就是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。 参考： JVM基础知识 JVM类加载机制 Java内存区域与内存溢出 那些情况下的对象会被垃圾回收机制处理掉？？？Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应的世代的区域中。一般的实现是划分为3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。 状态机Java的四种引用，强弱软虚，用到的场景。JDK1.2之前只有强引用，其他几种引用都是在JDK1.2之后引入的。 强引用（Strong Reference）最常用的引用类型，如Object obj = new Object(); 。只要强引用存在则GC时则必定不被回收。 软引用（Soft Reference）用于描述还有用但非必须的对象，当堆将发生OOM（Out Of Memory）时则会回收软引用所指向的内存空间，若回收后依然空间不足才会抛出OOM。一般用于实现内存敏感的高速缓存。当真正对象被标记finalizable以及的finalize()方法调用之后并且内存已经清理, 那么如果SoftReference object还存在就被加入到它的 ReferenceQueue.只有前面几步完成后,Soft Reference和Weak Reference的get方法才会返回null 弱引用（Weak Reference）发生GC时必定回收弱引用指向的内存空间。和软引用加入队列的时机相同 虚引用（Phantom Reference)又称为幽灵引用或幻影引用，虚引用既不会影响对象的生命周期，也无法通过虚引用来获取对象实例，仅用于在发生GC时接收一个系统通知。当一个对象的finalize方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了。虚引用和软引用、弱引用都不同，它会在内存没有清理的时候被加入引用队列。虚引用的建立必须要传入引用队列，其他可以没有。 数组复制请使用 System.arrayCopy 或 Arrays.copyOf 实现，且在 Java 中后者基于前者实现。 多线程一个线程的生命周期线程是一个动态执行的过程，它也有一个从产生到死亡的过程。 下图显示了一个线程完整的生命周期。 新建状态:使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 就绪状态:当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 运行状态:如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 阻塞状态:如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 死亡状态: 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 Java 线程几种用法进程和线程的区别程序是一段静态的代码。一个进程可以有一个或多个线程，每个线程都有一个唯一的标识符。 进程和线程的区别为：进程空间大体分为数据区、代码区、栈区、堆区。多个进程的内部数据和状态都是完全独立的；而线程共享进程的数据区、代码区、堆区，只有栈区是独立的，所以线程切换比进程切换的代价小。 多线程技术是使得单个程序内部可以在同一时刻执行多个代码段，完成不同的任务，这种机制称为多线程。同时并不是指真正意义上的同一时刻，而是指多个线程轮流占用CPU的时间片。 简而言之，一个程序至少有一个进程，一个进程至少有一个线程。 线程的划分尺度小于进程，使得多线程程序的并发性高。 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行. 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 什么会导致线程阻塞线程被堵塞可能是由下述五方面的原因造成的： 调用sleep(毫秒数)，使线程进入“睡眠”状态。在规定的时间内，这个线程是不会运行的。 用suspend()暂停了线程的执行。除非线程收到resume()消息，否则不会返回“可运行”状态。 用wait()暂停了线程的执行。除非线程收到nofify()或者notifyAll()消息，否则不会变成“可运行”。 线程正在等候一些IO（输入输出）操作完成。 线程试图调用另一个对象的“同步”方法，但那个对象处于锁定状态，暂时无法使用。 启动一个线程是用run()还是start()?启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态，一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码。 多线程有几种实现方法,都是什么?Java 提供了三种创建线程的方法： 通过实现 Runable 接口； 通过继承 Thread类本身； 通过 Callable 和 Future 创建线程。 多线程有两种实现方法，分别是继承Thread类与实现Runnable接口。 Java 5以前实现多线程有两种实现方法：一种是继承Thread类；另一种是实现Runnable接口。两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。 实现Runnable接口相比继承Thread类有如下优势： 可以避免由于Java的单继承特性而带来的局限 增强程序的健壮性，代码能够被多个程序共享，代码与数据是独立的 适合多个相同程序代码的线程区处理同一资源的情况 补充：Java 5以后创建线程还有第三种方式：实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值，代码如下所示： 123456789101112131415161718192021222324252627282930313233343536class MyTask implements Callable&lt;Integer&gt; &#123; private int upperBounds; public MyTask(int upperBounds) &#123; this.upperBounds = upperBounds; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for(int i = 1; i &lt;= upperBounds; i++) &#123; sum += i; &#125; return sum; &#125; &#125; public class Test &#123; public static void main(String[] args) throws Exception &#123; List&lt;Future&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); ExecutorService service = Executors.newFixedThreadPool(10); for(int i = 0; i &lt; 10; i++) &#123; list.add(service.submit(new MyTask((int) (Math.random() * 100)))); &#125; int sum = 0; for(Future&lt;Integer&gt; future : list) &#123; while(!future.isDone()) ; sum += future.get(); &#125; System.out.println(sum); &#125; &#125; 同步有几种实现方法,都是什么?同步的实现方面有两种，分别是synchronized、wait与notify 锁的等级方法锁、对象锁、类锁 同步和异步的区别？同步：A线程要请求某个资源，但是此资源正在被B线程使用中，因为同步机制存在，A线程请求不到，怎么办，A线程只能等待下去 异步：A线程要请求某个资源，但是此资源正在被B线程使用中，因为没有同步机制存在，A线程仍然请求的到，A线程无需等待 在进行网络编程时，我们通常会看到同步、异步、阻塞、非阻塞四种调用方式以及他们的组合。 其中同步方式、异步方式主要是由客户端（client）控制的，具体如下： 同步（Sync） 所谓同步，就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。 异步（Async） 异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。 sleep和wait有什么区别？一个是用来让线程休息，一个是用来挂起线程 对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。 sleep()：正在执行的线程主动让出CPU（然后CPU就可以去执行其他任务），在sleep指定时间后CPU再回到该线程继续往下执行。注意：sleep方法只让出了CPU，而并不会释放同步资源锁！ wait()：则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了notify()方法，之前调用wait()的线程才会解除wait状态，可以去参与竞争同步资源锁，进而得到执行 sleep()方法是线程类（Thread）的静态方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复（线程回到就绪（ready）状态），因为调用sleep 不会释放对象锁。 wait()是Object 类的方法，对此对象调用wait()方法导致本线程放弃对象锁(线程暂停执行)，进入等待此对象的等待锁定池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入就绪状态。 Java线程池，线程同步详细讲解一下 synchronized在并发编程中，多线程同时并发访问的资源叫做临界资源，当多个线程同时访问对象并要求操作相同资源时，分割了原子操作就有可能出现数据的不一致或数据不完整的情况，为避免这种情况的发生，我们会采取同步机制，以确保在某一时刻，方法内只允许有一个线程。 采用synchronized修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。每个对象都有一个monitor(锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池。任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做互斥锁。 这里就使用同步机制获取互斥锁的情况，进行几点说明： 如果同一个方法内同时有两个或更多线程，则每个线程有自己的局部变量拷贝。 类的每个实例都有自己的对象级别锁。当一个线程访问实例对象中的synchronized同步代码块或同步方法时，该线程便获取了该实例的对象级别锁，其他线程这时如果要访问synchronized同步代码块或同步方法，便需要阻塞等待，直到前面的线程从同步代码块或方法中退出，释放掉了该对象级别锁。 访问同一个类的不同实例对象中的同步代码块，不存在阻塞等待获取对象锁的问题，因为它们获取的是各自实例的对象级别锁，相互之间没有影响。 持有一个对象级别锁不会阻止该线程被交换出来，也不会阻塞其他线程访问同一示例对象中的非synchronized代码。当一个线程A持有一个对象级别锁（即进入了synchronized修饰的代码块或方法中）时，线程也有可能被交换出去，此时线程B有可能获取执行该对象中代码的时间，但它只能执行非同步代码（没有用synchronized修饰），当执行到同步代码时，便会被阻塞，此时可能线程规划器又让A线程运行，A线程继续持有对象级别锁，当A线程退出同步代码时（即释放了对象级别锁），如果B线程此时再运行，便会获得该对象级别锁，从而执行synchronized中的代码。 持有对象级别锁的线程会让其他线程阻塞在所有的synchronized代码外。例如，在一个类中有三个synchronized方法a，b，c，当线程A正在执行一个实例对象M中的方法a时，它便获得了该对象级别锁，那么其他的线程在执行同一实例对象（即对象M）中的代码时，便会在所有的synchronized方法处阻塞，即在方法a，b，c处都要被阻塞，等线程A释放掉对象级别锁时，其他的线程才可以去执行方法a，b或者c中的代码，从而获得该对象级别锁。 使用synchronized（obj）同步语句块，可以获取指定对象上的对象级别锁。obj为对象的引用，如果获取了obj对象上的对象级别锁，在并发访问obj对象时时，便会在其synchronized代码处阻塞等待，直到获取到该obj对象的对象级别锁。当obj为this时，便是获取当前对象的对象级别锁。 类级别锁被特定类的所有示例共享，它用于控制对static成员变量以及static方法的并发访问。具体用法与对象级别锁相似。 互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。synchronized关键字经过编译后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁，如果获得了锁，把锁的计数器加1，相应地，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁便被释放了。由于synchronized同步块对同一个线程是可重入的，因此一个线程可以多次获得同一个对象的互斥锁，同样，要释放相应次数的该互斥锁，才能最终释放掉该锁。 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? 可以调用此对象的其他非 synchronized 方法； 可以调用此对象的 synchronized static 方法； 1234567891011121314151617181920public class A &#123; /** * 静态方法 */ public synchronized static void staticMethod()&#123;&#125; /** * 实例方法 */ public synchronized void instanceMethod()&#123;&#125; public static void main(String[] args) &#123; //A实例的创建过程 Class c = Class.forName("A"); A a1 = c.newInstance(); A a2 = c.newInstance(); A a3 = c.newInstance(); &#125;&#125; 如上代码所示，你看一看main方法里面A实例的创建过程，这个要先理解staticMethod这个静态方法，无法你实例化多少次，它都只是存在一个，就像Class c指向的对象，它在jvm中也只会存在一个，staticMethod方法锁住的是c指向的实例。 instanceMethod这个实例方法，你创建多少个A实例，这些实例都存在各自的instanceMethod方法，这个方法前加synchronized关键词，会锁住该instanceMethod方法所在的实例。如a1的instanceMethod方法会锁住a1指向的实例，a2的instanceMethod会锁住a2指向的实例。 由此得出结论，staticMethod与instanceMethod锁住的对象是不可能相同的，这就是两个方法不能同步的原因。 内存可见性加锁（synchronized同步）的功能不仅仅局限于互斥行为，同时还存在另外一个重要的方面：内存可见性。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且还希望确保当一个线程修改了对象状态后，其他线程能够看到该变化。而线程的同步恰恰也能够实现这一点。 内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果。为了确保所有的线程都能看到共享变量的最新值，可以在所有执行读操作或写操作的线程上加上同一把锁。下图示例了同步的可见性保证。 当线程A执行某个同步代码块时，线程B随后进入由同一个锁保护的同步代码块，这种情况下可以保证，当锁被释放前，A看到的所有变量值（锁释放前，A看到的变量包括y和x）在B获得同一个锁后同样可以由B看到。换句话说，当线程B执行由锁保护的同步代码块时，可以看到线程A之前在同一个锁保护的同步代码块中的所有操作结果。如果在线程A unlock M之后，线程B才进入lock M，那么线程B都可以看到线程A unlock M之前的操作，可以得到i=1，j=1。如果在线程B unlock M之后，线程A才进入lock M，那么线程B就不一定能看到线程A中的操作，因此j的值就不一定是1。 现在考虑如下代码： 1234567891011public class MutableInteger &#123; private int value; public int get()&#123; return value; &#125; public void set(int value)&#123; this.value = value; &#125; &#125; 以上代码中，get和set方法都在没有同步的情况下访问value。如果value被多个线程共享，假如某个线程调用了set，那么另一个正在调用get的线程可能会看到更新后的value值，也可能看不到。 通过对set和get方法进行同步，可以使MutableInteger成为一个线程安全的类，如下： 1234567891011public class SynchronizedInteger &#123; private int value; public synchronized int get()&#123; return value; &#125; public synchronized void set(int value)&#123; this.value = value; &#125; &#125; 对set和get方法进行了同步，加上了同一把对象锁，这样get方法可以看到set方法中value值的变化，从而每次通过get方法取得的value的值都是最新的value值。 Atomic、volatile、synchronized区别面Java基础的时候遇上了这个问题，说如果只有一个i++;的时候，volatile和synchronized能否互换。当时也不知道，感觉volatile作为修饰变量的时候，变量自加会出现加到一半发生线程调度。再看看当时蒙对了。 volatile可以保证在一个线程的工作内存中修改了该变量的值，该变量的值立即能回显到主内存中，从而保证所有的线程看到这个变量的值是一致的。但是有个前提，因为它不具有操作的原子性，也就是它不适合在对该变量的写操作依赖于变量本身自己。就比如i++、i+=1;这种。但是可以改为num=i+1;如果i是一个 volatile 类型，那么num就是安全的，总之就是不能作用于自身。 synchronized是基于代码块的，只要包含在synchronized块中，就是线程安全的。 既然都说了线程安全，就多了解几个： AtomicInteger，一个轻量级的synchronized。使用的并不是同步代码块，而是Lock-Free算法(我也不懂，看代码就是一个死循环调用了底层的比较方法直到相同后才退出循环)。最终的结果就是在高并发的时候，或者说竞争激烈的时候效率比synchronized高一些。 ThreadLocal，线程中私有数据。主要用于线程改变内部的数据时不影响其他线程，使用时需要注意static。 详细分析见这篇文章 。 再补一个，才学到的。利用clone()方法，如果是一个类的多个对象想共用对象内部的一个变量，而又不想这个变量static，可以使用浅复制方式。(查看设计模式原型模式) 并发编程中实现内存可见的两种方法比较：加锁和volatile变量 volatile变量是一种稍弱的同步机制在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。 从内存可见性的角度看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。 在代码中如果过度依赖volatile变量来控制状态的可见性，通常会比使用锁的代码更脆弱，也更难以理解。仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它。一般来说，用同步机制会更安全些。 加锁机制（即同步机制）既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性，原因是声明为volatile的简单变量如果当前值与该变量以前的值相关，那么volatile关键字不起作用，也就是说如下的表达式都不是原子操作：“count++”、“count = count+1”。 当且仅当满足以下所有条件时，才应该使用volatile变量： 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。 该变量没有包含在具有其他变量的不变式中。 总结：在需要同步的时候，第一选择应该是synchronized关键字，这是最安全的方式，尝试其他任何方式都是有风险的。尤其在、jdK1.5之后，对synchronized同步机制做了很多优化，如：自适应的自旋锁、锁粗化、锁消除、轻量级锁等，使得它的性能明显有了很大的提升。 用wait/notify来实现最简单的生产者-消费者模式生产者和消费者问题 守护线程与阻塞线程的四种情况Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 用户线程即运行在前台的线程，而守护线程是运行在后台的线程。 守护线程作用是为其他前台线程的运行提供便利服务，而且仅在普通、非守护线程仍然运行时才需要，比如垃圾回收线程就是一个守护线程。当VM检测仅剩一个守护线程，而用户线程都已经退出运行时，VM就会退出，因为如果没有了守护者，也就没有继续运行程序的必要了。如果有非守护线程仍然活着，VM就不会退出。 守护线程并非只有虚拟机内部提供，用户在编写程序时也可以自己设置守护线程。用户可以用Thread的setDaemon(true)方法设置当前线程为守护线程。 虽然守护线程可能非常有用，但必须小心确保其它所有非守护线程消亡时，不会由于它的终止而产生任何危害。因为你不可能知道在所有的用户线程退出运行前，守护线程是否已经完成了预期的服务任务。一旦所有的用户线程退出了，虚拟机也就退出运行了。因此，不要再守护线程中执行业务逻辑操作(比如对数据的读写等)。 还有几点： setDaemon(true)必须在调用线程的start()方法之前设置，否则会跑出IllegalThreadStateException异常。 在守护线程中产生的新线程也是守护线程 不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。 死锁当线程需要同时持有多个锁时，有可能产生死锁。考虑如下情形： 线程A当前持有互斥所锁lock1，线程B当前持有互斥锁lock2。接下来，当线程A仍然持有lock1时，它试图获取lock2，因为线程B正持有lock2，因此线程A会阻塞等待线程B对lock2的释放。如果此时线程B在持有lock2的时候，也在试图获取lock1，因为线程A正持有lock1，因此线程B会阻塞等待A对lock1的释放。二者都在等待对方所持有锁的释放，而二者却又都没释放自己所持有的锁，这时二者便会一直阻塞下去。这种情形称为死锁。 下面给出一个两个线程间产生死锁的示例，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class Deadlock &#123; private String objID; public Deadlock(String id) &#123; objID = id; &#125; public synchronized void checkOther(Deadlock other) &#123; print("entering checkOther()"); try &#123; Thread.sleep(2000); &#125; catch ( InterruptedException x ) &#123; &#125; print("in checkOther() - about to " + "invoke 'other.action()'"); //调用other对象的action方法，由于该方法是同步方法，因此会试图获取other对象的对象锁 other.action(); print("leaving checkOther()"); &#125; public synchronized void action() &#123; print("entering action()"); try &#123; Thread.sleep(500); &#125; catch ( InterruptedException x ) &#123; &#125; print("leaving action()"); &#125; public void print(String msg) &#123; threadPrint("objID=" + objID + " - " + msg); &#125; public static void threadPrint(String msg) &#123; String threadName = Thread.currentThread().getName(); System.out.println(threadName + ": " + msg); &#125; public static void main(String[] args) &#123; final Deadlock obj1 = new Deadlock("obj1"); final Deadlock obj2 = new Deadlock("obj2"); Runnable runA = new Runnable() &#123; public void run() &#123; obj1.checkOther(obj2); &#125; &#125;; Thread threadA = new Thread(runA, "threadA"); threadA.start(); try &#123; Thread.sleep(200); &#125; catch ( InterruptedException x ) &#123; &#125; Runnable runB = new Runnable() &#123; public void run() &#123; obj2.checkOther(obj1); &#125; &#125;; Thread threadB = new Thread(runB, "threadB"); threadB.start(); try &#123; Thread.sleep(5000); &#125; catch ( InterruptedException x ) &#123; &#125; threadPrint("finished sleeping"); threadPrint("about to interrupt() threadA"); threadA.interrupt(); try &#123; Thread.sleep(1000); &#125; catch ( InterruptedException x ) &#123; &#125; threadPrint("about to interrupt() threadB"); threadB.interrupt(); try &#123; Thread.sleep(1000); &#125; catch ( InterruptedException x ) &#123; &#125; threadPrint("did that break the deadlock?"); &#125;&#125; 运行结果： 12345678threadA: objID=obj1 - entering checkOther()threadB: objID=obj2 - entering checkOther()threadA: objID=obj1 - in checkOther() - about to invoke 'other.action()'threadB: objID=obj2 - in checkOther() - about to invoke 'other.action()'main: finished sleepingmain: about to interrupt() threadAmain: about to interrupt() threadBmain: did that break the deadlock? 从结果中可以看出，在执行到other.action（）时，由于两个线程都在试图获取对方的锁，但对方都没有释放自己的锁，因而便产生了死锁，在主线程中试图中断两个线程，但都无果。 大部分代码并不容易产生死锁，死锁可能在代码中隐藏相当长的时间，等待不常见的条件地发生，但即使是很小的概率，一旦发生，便可能造成毁灭性的破坏。避免死锁是一件困难的事，遵循以下原则有助于规避死锁： 只在必要的最短时间内持有锁，考虑使用同步语句块代替整个同步方法； 尽量编写不在同一时刻需要持有多个锁的代码，如果不可避免，则确保线程持有第二个锁的时间尽量短暂； 创建和使用一个大锁来代替若干小锁，并把这个锁用于互斥，而不是用作单个对象的对象级别锁； 可重入内置锁每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁或监视器锁。线程在进入同步代码块之前会自动获取锁，并且在退出同步代码块时会自动释放锁。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。 当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果摸个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是调用。重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程所持有，当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1，如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。 重入进一步提升了加锁行为的封装性，因此简化了面向对象并发代码的开发。分析如下程序： 1234567891011121314public class Father &#123; public synchronized void doSomething()&#123; ...... &#125; &#125; public class Child extends Father &#123; public synchronized void doSomething()&#123; ...... super.doSomething(); &#125; &#125; 子类覆写了父类的同步方法，然后调用父类中的方法，此时如果没有可重入的锁，那么这段代码件产生死锁。 由于Fither和Child中的doSomething方法都是synchronized方法，因此每个doSomething方法在执行前都会获取Child对象实例上的锁。如果内置锁不是可重入的，那么在调用super.doSomething时将无法获得该Child对象上的互斥锁，因为这个锁已经被持有，从而线程会永远阻塞下去，一直在等待一个永远也无法获取的锁。重入则避免了这种死锁情况的发生。 同一个线程在调用本类中其他synchronized方法/块或父类中的synchronized方法/块时，都不会阻碍该线程地执行，因为互斥锁时可重入的。 使用wait/notify/notifyAll实现线程间通信在Java中，可以通过配合调用Object对象的wait（）方法和notify（）方法或notifyAll（）方法来实现线程间的通信。在线程中调用wait（）方法，将阻塞等待其他线程的通知（其他线程调用notify（）方法或notifyAll（）方法），在线程中调用notify（）方法或notifyAll（）方法，将通知其他线程从wait（）方法处返回。 Object是所有类的超类，它有5个方法组成了等待/通知机制的核心：notify（）、notifyAll（）、wait（）、wait（long）和wait（long，int）。在Java中，所有的类都从Object继承而来，因此，所有的类都拥有这些共有方法可供使用。而且，由于他们都被声明为final，因此在子类中不能覆写任何一个方法。 这里详细说明一下各个方法在使用中需要注意的几点： 1、wait（） 1public final void wait() throws InterruptedException,IllegalMonitorStateException 该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。在调用wait（）之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait（）方法。进入wait（）方法后，当前线程释放锁。在从wait（）返回前，线程与其他线程竞争重新获得锁。如果调用wait（）时，没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch结构。 2、notify（） 1public final native void notify() throws IllegalMonitorStateException 该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，的如果调用notify（）时没有持有适当的锁，也会抛出IllegalMonitorStateException。 该方法用来通知那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程规划器任意挑选出其中一个wait（）状态的线程来发出通知，并使它等待获取该对象的对象锁（notify后，当前线程不会马上释放该对象锁，wait所在的线程并不能马上获取该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁），但不惊动其他同样在等待被该对象notify的线程们。当第一个获得了该对象锁的wait线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。这里需要注意：它们等待的是被notify或notifyAll，而不是锁。这与下面的notifyAll（）方法执行后的情况不同。 3、notifyAll（） 1public final native void notifyAll() throws IllegalMonitorStateException 该方法与notify（）方法的工作方式相同，重要的一点差异是： notifyAll使所有原来在该对象上wait的线程统统退出wait的状态（即全部被唤醒，不再等待notify或notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），变成等待获取该对象上的锁，一旦该对象锁被释放（notifyAll线程退出调用了notifyAll的synchronized代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。 4、wait（long）和wait（long,int） 显然，这两个方法是设置等待超时时间的，后者在超值时间上加上ns，精度也难以达到，因此，该方法很少使用。对于前者，如果在等待线程接到通知或被中断之前，已经超过了指定的毫秒数，则它通过竞争重新获得锁，并从wait（long）返回。另外，需要知道，如果设置了超时时间，当wait（）返回时，我们不能确定它是因为接到了通知还是因为超时而返回的，因为wait（）方法不会返回任何相关的信息。但一般可以通过设置标志位来判断，在notify之前改变标志位的值，在wait（）方法后读取该标志位的值来判断，当然为了保证notify不被遗漏，我们还需要另外一个标志位来循环判断是否调用wait（）方法。 深入理解： 如果线程调用了对象的wait（）方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。 当有线程调用了对象的notifyAll（）方法（唤醒所有wait线程）或notify（）方法（只随机唤醒一个wait线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait（）方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了synchronized代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。 线程中断参考： 线程中断 Error 和 ExceptionError与Exception的区别Error是Throwable的子类，用于标记严重错误。合理的应用程序不应该去try/catch这种错误。绝大多数的错误都是非正常的，就根本不该出现的。 Exception 是Throwable的一种形式的子类，用于指示一种合理的程序想去catch的条件。即它仅仅是一种程序运行条件，而非严重错误，并且鼓励用户程序去catch它。 checked exceptions: 通常是从一个可以恢复的程序中抛出来的，并且最好能够从这种异常中使用程序恢复。比如FileNotFoundException, ParseException等。 unchecked exceptions: 通常是如果一切正常的话本不该发生的异常，但是的确发生了。比如ArrayIndexOutOfBoundException, ClassCastException等。从语言本身的角度讲，程序不该去catch这类异常，虽然能够从诸如RuntimeException这样的异常中catch并恢复，但是并不鼓励终端程序员这么做，因为完全没要必要。因为这类错误本身就是bug，应该被修复，出现此类错误时程序就应该立即停止执行。 因此，面对Errors和unchecked exceptions应该让程序自动终止执行，程序员不该做诸如try/catch这样的事情，而是应该查明原因，修改代码逻辑。 Java中的异常处理机制的简单原理和应用。JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？ Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。用try来指定一块预防所有“异常”的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的“异常”的类型。throw语句用来明确地抛出一个“异常”。throws用来标明一个成员函数可能抛出的各种“异常”。Finally为确保一段代码不管发生什么“异常”都被执行一段代码。可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try语句，“异常”的框架就放到堆栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种“异常”进行处理，堆栈就会展开，直到遇到有处理这种“异常”的try语句。 try{ return} catch{} finally{}; return 还是 finally 先执行。任何执行try 或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。 如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的。 在try语句中，在执行return语句时，要返回的结果已经准备好了，就在此时，程序转到finally执行了。在转去之前，try中先把要返回的结果存放到不同于x的局部变量中去，执行完finally之后，在从中取出返回结果，因此，即使finally中对变量x进行了改变，但是不会影响返回结果。 序列化对象Object读写的是哪两个流ObjectInputStream ObjectOutputStream 什么是Java序列化，如何实现java序列化序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。 序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。 Serializable和Parcelable注解注解原理反射反射原理反射机制java反射机制是在运行状态中，对于任意一个类， 都能够知道这个类的所有属性和方法；对于任意一个对象， 都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 主要作用有三： 运行时取得类的方法和字段的相关信息。 创建某个类的新实例(.newInstance()) 取得字段引用直接获取和设置对象字段，无论访问修饰符是什么。 用处如下： 观察或操作应用程序的运行时行为。 调试或测试程序，因为可以直接访问方法、构造函数和成员字段。 通过名字调用不知道的方法并使用该信息来创建对象和调用方法。 Java类加载机制泛型泛型的优缺点优点： 使用泛型类型可以最大限度地重用代码、保护类型的安全以及提高性能。泛型最常见的用途是创建集合类。 缺点： 在性能上不如数组快。 泛型常用特点，List&lt;String&gt;能否转为List&lt;Object&gt;能，但是利用类都继承自Object，所以使用是每次调用里面的函数都要通过强制转换还原回原来的类，这样既不安全，运行速度也慢。 网络TCP与UDP的区别 TCP UDP TCP面向有链接的通信服务 UDP面向无连接的通信服务 TCP提供可靠的通信传输 UDP不可靠，会丢包 TCP保证数据顺序 UDP不保证 TCP数据无边界 UDP有边界 TCP速度慢 UDP速度快 TCP面向字节流 UDP面向报文 TCP一对一 UDP可以一对一，一对多 TCP报头至少20字节 UDP报头8字节 TCP有流量控制，拥塞控制 UDP没有 http get 和 post 的区别 GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连，如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 POST把提交的数据则放置在是HTTP包的包体中。 GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据。 首先是”GET方式提交的数据最多只能是1024字节”，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。 注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。 POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了。 GET - 从指定的服务器中获取数据POST - 提交数据给指定的服务器处理 GET方法：使用GET方法时，查询字符串（键值对）被附加在URL地址后面一起发送到服务器：/test/demo_form.jsp?name1=value1&amp;name2=value2特点： 12345GET请求能够被缓存GET请求会保存在浏览器的浏览记录中以GET请求的URL能够保存为浏览器书签GET请求有长度限制GET请求主要用以获取数据 POST方法：使用POST方法时，查询字符串在POST信息中单独存在，和HTTP请求一起发送到服务器：POST /test/demo_form.jsp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2特点： 1234POST请求不能被缓存下来POST请求不会保存在浏览器浏览记录中以POST请求的URL无法保存为浏览器书签POST请求没有长度限制 Post一般用于更新或者添加资源信息 Get一般用于查询操作，而且应该是安全和幂等的 Post更加安全 Get会把请求的信息放到URL的后面 Post传输量一般无大小限制 Get不能大于2KB Post执行效率低 Get执行效率略高 https的那个s是什么意思UDP 和 TCP 的区别 基于连接与无连接； 对系统资源的要求（TCP较多，UDP少）； UDP程序结构较简单； 流模式与数据包模式 ； TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。 TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。 UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。 TCP是Tranfer Control Protocol的 简称，是一种面向连接的保证可靠传输的协议。通过TCP协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两个socket之间必须建 立连接，以便在TCP协议的基础上进行通信，当一个socket（通常都是server socket）等待建立连接时，另一个socket可以要求进行连接，一旦这两个socket连接起来，它们就可以进行双向数据传输，双方都可以进行发送 或接收操作。 UDP是User Datagram Protocol的简称，是一种无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。 比较： UDP： 1，每个数据报中都给出了完整的地址信息，因此无需要建立发送方和接收方的连接。 2，UDP传输数据时是有大小限制的，每个被传输的数据报必须限定在64KB之内。 3，UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方 TCP： 1，面向连接的协议，在socket之间进行数据传输之前必然要建立连接，所以在TCP中需要连接时间。 2，TCP传输数据大小限制，一旦连接建立起来，双方的socket就可以按统一的格式传输大的数据。 3，TCP是一个可靠的协议，它确保接收方完全正确地获取发送方所发送的全部数据。 应用： 1，TCP在网络通信上有极强的生命力，例如远程连接（Telnet）和文件传输（FTP）都需要不定长度的数据被可靠地传输。但是可靠的传输是要付出代价的，对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽，因此TCP传输的效率不如UDP高。 2，UDP操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中client/server应用程序。例如视频会议系统，并不要求音频视频数据绝对的正确，只要保证连贯性就可以了，这种情况下显然使用UDP会更合理一些。 TCP与UDP面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。 TCP协议 Transmission Control Protocol，传输控制协议 面向连接的协议 需要三次握手建立连接 需要四次挥手断开连接 TCP报头最小长度：20字节 三次握手的过程： 客户端发送：SYN = 1, SEQ = X, 端口号 服务器回复：SYN = 1, ACK = X + 1, SEQ = Y 客户端发送：ACK = Y + 1, SEQ = X + 1 确认应答信号ACK = 收到的SEQ + 1。连接建立中，同步信号SYN始终为1。连接建立后，同步信号SYN=0。 四次挥手过程 A向B提出停止连接请求，FIN = 1 B收到，ACK = 1 B向A提出停止连接请求，FIN = 1 A收到，ACK = 1 优点： 可靠，稳定 1、传递数据前，会有三次握手建立连接 2、传递数据时，有确认、窗口、重传、拥塞控制 3、传递数据后，会断开连接节省系统资源 缺点： 传输慢，效率低，占用系统资源高1、传递数据前，建立连接需要耗时2、传递数据时，确认、重传、拥塞等会消耗大量时间以及CPU和内存等硬件资源 易被攻击1、因为有确认机制，三次握手等机制，容易被人利用，实现DOS 、DDOS攻击 如何保证接收的顺序性：TCP协议使用SEQ和ACK机制保证了顺序性TCP的每个报文都是有序号的。确认应答信号ACK=收到的SEQ+1 TCP的三次握手，和四次挥手，为什么需要三次握手，为什么要四次挥手UDP协议 User Data Protocol，用户数据包协议 面向无连接的协议 UDP报头只有8字节 简介： 传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快的把它扔到网络上 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息 UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制 UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表。 UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。 使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。 优点： 传输速率快1、传输数据前，不需要像TCP一样建立连接2、传输数据时，没有确认、窗口、重传、拥塞控制等机制 较安全1、由于没有了TCP的一些机制，被攻击者利用的漏洞就少了 缺点： 不可靠，不稳定1、由于没有了TCP的机制，在数据传输时如果网络不好，很可能丢包 用UDP协议通讯时怎样得知目标机是否获得了数据包仿造TCP的做法，每发一个UDP包，都在里面加一个SEQ序号，接收方收到包后，将SEQ序号回复给发送方。如果发送方在指定时间以内没有收到回应，说明丢包了。 为什么UDP比TCP快 TCP需要三次握手 TCP有拥塞控制，控制流量等机制 为什么TCP比UDP可靠 TCP是面向有连接的，建立连接之后才发送数据；而UDP则不管对方存不存在都会发送数据。 TCP有确认机制，接收端每收到一个正确包都会回应给发送端。超时或者数据包不完整的话发送端会重传。UDP没有，因此可能丢包。 什么时候使用TCP当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。在日常生活中，常见使用TCP协议的应用如下：浏览器，用的HTTPFlashFXP，用的FTPOutlook，用的POP、SMTPPutty，用的Telnet、SSHQQ文件传输 什么时候应该使用UDP当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。比如，日常生活中，常见使用UDP协议的应用如下：QQ语音QQ视频TFTP TCP无边界，UDP有边界TCP无边界 客户端分多次发送数据给服务器，若服务器的缓冲区够大，那么服务器端会在客户端发送完之后一次性接收过来，所以是无边界的； UDP有边界 客户端每发送一次，服务器端就会接收一次，也就是说发送多少次就会接收多少次，因此是有边界的。 Socket编程的步骤Server端Listen(监听)某个端口是否有连接请求，Client端向Server 端发出Connect(连接)请求，Server端向Client端发回Accept（接受）消息。一个连接就建立起来了。Server端和Client 端都可以通过Send，Write等方法与对方通信。 对于一个功能齐全的Socket，都要包含以下基本结构，其工作过程包含以下四个基本的步骤： （1） 创建Socket； （2） 打开连接到Socket的输入/出流； （3） 按照一定的协议对Socket进行读/写操作； （4） 关闭Socket.（在实际应用中，并未使用到显示的close，虽然很多文章都推荐如此，不过在我的程序中，可能因为程序本身比较简单，要求不高，所以并未造成什么影响。） IOIO框架主要用到什么设计模式JDK的I/O包中就主要使用到了两种设计模式：Adatper模式和Decorator模式。NIO包有哪些结构？分别起到的作用？NIO NIO针对什么情景会比IO有更好的优化？OKIO底层实现jsonJSON，fastjson 和 GSON的区别1.json-lib json-lib最开始的也是应用最广泛的json解析工具，json-lib 不好的地方确实是依赖于很多第三方包，包括commons-beanutils.jar，commons-collections-3.2.jar，commons-lang-2.6.jar，commons-logging-1.1.1.jar，ezmorph-1.0.6.jar，对于复杂类型的转换，json-lib对于json转换成bean还有缺陷，比如一个类里面会出现另一个类的list或者map集合，json-lib从json到bean的转换就会出现问题。 json-lib在功能和性能上面都不能满足现在互联网化的需求。 2.开源的Jackson 相比json-lib框架，Jackson所依赖的jar包较少，简单易用并且性能也要相对高些。而且Jackson社区相对比较活跃，更新速度也比较快。 Jackson对于复杂类型的json转换bean会出现问题，一些集合Map，List的转换出现问题。Jackson对于复杂类型的bean转换Json，转换的json格式不是标准的Json格式 3.Google的Gson Gson是目前功能最全的Json解析神器，Gson当初是为因应Google公司内部需求而由Google自行研发而来，但自从在2008年五月公开发布第一版后已被许多公司或用户应用。 Gson的应用主要为toJson与fromJson两个转换函数，无依赖，不需要例外额外的jar，能够直接跑在JDK上。 而在使用这种对象转换之前需先创建好对象的类型以及其成员才能成功的将JSON字符串成功转换成相对应的对象。类里面只要有get和set方法，Gson完全可以将复杂类型的json到bean或bean到json的转换，是JSON解析的神器。 Gson在功能上面无可挑剔，但是性能上面比FastJson有所差距。 4.阿里巴巴的FastJson Fastjson是一个Java语言编写的高性能的JSON处理器,由阿里巴巴公司开发。无依赖，不需要例外额外的jar，能够直接跑在JDK上。 FastJson在复杂类型的Bean转换Json上会出现一些问题，可能会出现引用的类型，导致Json转换出错，需要制定引用。 FastJson采用独创的算法，将parse的速度提升到极致，超过所有json库。 xmlXML，解析XML的几种方式的原理与特点：DOM、SAX、PULL参考：http://www.cnblogs.com/HaroldTihan/p/4316397.html JNI参考：http://landerlyoung.github.io/blog/2014/10/16/java-zhong-jnide-shi-yong/ MD5加密原理，可否解密。排序算法常见排序算法的时间复杂度 Java 排序算法参考：http://blog.csdn.net/qy1387/article/details/7752973]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 面试之开篇]]></title>
      <url>http://eddy.wiki/interview-start.html</url>
      <content type="text"><![CDATA[本文出自 Eddy Wiki ，转载请注明出处：http://eddy.wiki/interview-start.html 由于最近准备转行搞 Android 应用开发，故在面试准备期间把 Android 面试相关的知识等整理成 “Android 面试系列” 文章。在整理的过程中复习 Android 的相关知识，并留下一些记录，希望对其他的 Android 面试者有一定的帮助。 Android 面试系列目录 Android 面试之 Java 篇 Android 面试之 Android 篇 Android 面试之简历篇 Android 面试之面试官提问篇 Android 面试之某些公司的面试题 Android 面试之常用开源库 Android 面试之排序算法 Android 面试之编程算法题 参考来源链接 Android 学习资料收集 史上最全Android面试资料集合 国内一线互联网公司内部面试题库 LearningNotes Android 名企面试题及涉及知识点整理 2016某公司面试题 Android 面试题集合 Android 面试基础知识总结 Android 面试题整理 Android 面试复习 其他… 说明 “Android 面试” 系列文章是本人参考上面的网站、文章等整理而成，在此感谢以上网站、文章的作者，谢谢！如果你觉得该系列文章对你的权益造成了侵害，那么请在本文下面留言，我会删除相关的文章。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CocosCreator 集成 AnySDK 教程]]></title>
      <url>http://eddy.wiki/creator-anysdk.html</url>
      <content type="text"><![CDATA[本文出自 Eddy Wiki ，转载请注明出处：http://eddy.wiki/creator-anysdk.html 本文主要介绍怎么在 CocosCreator 项目中集成 AnySDK 。 本人开发环境CocosCreator 1.1.1, AnySDK 2.1.2, AnySDK_Framework_JS_Android_2.1.2, MacOS 10.10.3 Android 平台集成 AnySDK 详细步骤由于本人使用 git 对项目进行版本控制管理，所以下列步骤中会有一些与 git 相关的操作。如果你没有使用 git，那么你可以直接忽略下列步骤中与 git 相关的操作。 获取 AnySDK Framework安装 AnySDK 客户端，然后在 AnySDK 客户端的【安妮市场】【分类】【框架】中找到 JS(Android) 框架并下载。如下图： 下载完成后打开 JS(Android) 框架文件夹即可看到 AnySDKFiles/Store/Frameworks/AnySDK_Framework_JS_Android_2.1.2/AnySDK_Framework_JS(Android)/ 这样的目录。如下图： 下文统一使用 AnySDK_Framework_JS(Android) 指代 AnySDK Framework 文件目录。 构建并编译 CocosCreator 项目下文使用 your-proj 指代你的 CocosCreator 项目路径。 修改项目中的 gitignore 文件。删除 your-proj/.gitignore 文件中以下路径： build/ 在 your-proj/.gitignore 文件中添加以下路径： build/jsb-default/src/ build/jsb-default/res/ build/jsb-default/publish/ build/jsb-default/simulator/ build/jsb-default/frameworks/runtime-src/proj.android/bin/ build/jsb-default/frameworks/runtime-src/proj.android/gen/ build/jsb-default/frameworks/runtime-src/proj.android/obj/ build/jsb-default/frameworks/runtime-src/proj.android/assets/ build/jsb-default/frameworks/cocos2d-x/cocos/platform/android/java/bin/ build/jsb-default/frameworks/cocos2d-x/cocos/platform/android/java/gen/ 构建发布 Android 平台使用 CocosCreator 打开项目，点击 【项目】【构建发布】，发布平台选择 “Android”， 模板选择 “default”。然后点击 “构建”按钮 对项目进行构建。构建完毕会在 your-proj 目录下生成一个 build/jsb-default/ 目录。 构建完成后，点击 “编译”按钮 对项目进行编译，编译过程大概20分钟左右。编译完成后，安装编译生成的 apk 到手机上查看是否运行正常。 如果在构建和编译过程中出现错误，请参考 CocosCreator 官方的跨平台发布游戏文档。 注意：该步骤中的编译操作并不是必须的，只是为了保证你的编译发布 Android 平台相关开发环境已经配置完成。这样在集成 AnySDK 的出现错误的时候，就可以排除开发环境配置相关的问题了。 获取 anysdk jsb 绑定文件添加 anysdk jsb 文件在 build/jsb-default/frameworks/cocos2d-x/ 目录下新建 anysdk 文件夹，然后拷贝 AnySDK_Framework_JS(Android)/ 目录下的 src 文件夹到新建的 anysdk 文件夹中。 修改 build-cfg.json 文件在 build/jsb-default/frameworks/runtime-src/proj.android/build-cfg.json 文件中添加： 1234&#123; "from": "../../cocos2d-x/anysdk/src", "to": ""&#125; 如下图，注意：不要遗漏了添加代码前面分隔的逗号 “,”。 修改 jsb.js 文件在 build/jsb-default/frameworks/cocos2d-x/cocos/scripting/js-bindings/script/jsb.js 文件中添加： 1234567891011if (jsb.fileUtils.isFileExist('jsb_anysdk_constants.js') || jsb.fileUtils.isFileExist('jsb_anysdk_constants.jsc')) &#123; if (cc.sys.os == cc.sys.OS_IOS || cc.sys.os == cc.sys.OS_ANDROID) &#123; require('jsb_anysdk_constants.js'); &#125;&#125;if (jsb.fileUtils.isFileExist('jsb_anysdk.js') || jsb.fileUtils.isFileExist('jsb_anysdk.jsc')) &#123; if (cc.sys.os == cc.sys.OS_IOS || cc.sys.os == cc.sys.OS_ANDROID) &#123; require('jsb_anysdk.js'); &#125;&#125; 如下图 拷贝anysdk framework stl库添加 protocols 文件首先，查看所接入项目的 build/jsb-default/frameworks/runtime-src/proj.android/jni/application.mk 文件第一行找到 stl 库类型设置。 如下： APP_STL := gnustl_static 然后，进入所接入项目的 build/jsb-default/frameworks/runtime-src/proj.android 目录，新建 protocols 文件夹。根据上面查看到的stl类型，选取 AnySDK_Framework_JS(Android)/framework/protocols_gnustl_static/ 库，然后将该目录下的 android 和 include 文件夹拷贝到 protocols 目录下。 添加 libPluginProtocol.jar 文件在 build/jsb-default/frameworks/runtime-src/proj.android/ 目录下新建 libs 文件夹，然后将 build/jsb-default/frameworks/runtime-src/proj.android/protocols/android 目录下的 libPluginProtocol.jar 文件移到 libs 目录下。 添加 res 文件将 AnySDK_Framework_JS(Android)/framework/protocols_gnustl_static/ 目录下的 res 文件夹，拷贝到 build/jsb-default/frameworks/runtime-src/proj.android/ 目录下，注意选择合并，避免文件覆盖。 添加 Classes 文件由于 CocosCreator 1.1.1 使用的是 lite 版本引擎，所以不能使用 AnySDK_Framework_JS(Android)/3.10及以上/ 目录下的文件。请下载 anysdk-files-for-ccc，然后把 anysdk-files-for-ccc/build/jsb-default/frameworks/runtime-src/Classes/ 目录下的所有文件（除 AppDelegate.cpp 外），拷贝到 build/jsb-default/frameworks/runtime-src/Classes 目录下。 修改 AppDelegate.cpp 文件在 build/jsb-default/frameworks/runtime-src/Classes/AppDelegate.cpp 文件中添加： 12345#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID || CC_TARGET_PLATFORM == CC_PLATFORM_IOS)#include "jsb_anysdk_basic_conversions.h"#include "jsb_anysdk_protocols_auto.hpp"#include "manualanysdkbindings.hpp"#endif 1234#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID || CC_TARGET_PLATFORM == CC_PLATFORM_IOS) sc-&gt;addRegisterCallback(register_all_anysdk_framework); sc-&gt;addRegisterCallback(register_all_anysdk_manual);#endif 如下图 修改 Android.mk 文件在 build/jsb-default/frameworks/runtime-src/proj.android/jni/Android.mk 文件中添加： 1$(call import-add-path,$(LOCAL_PATH)/../) 1234../../Classes/jsb/jsb_creator_auto.cpp \../../Classes/jsb_anysdk_basic_conversions.cpp \../../Classes/jsb_anysdk_protocols_auto.cpp \../../Classes/manualanysdkbindings.cpp 1LOCAL_WHOLE_STATIC_LIBRARIES := PluginProtocolStatic 1$(call import-module, protocols/android) 如下图，注意：记得在 ../../Classes/AppDelegate.cpp 后添加 “\”。 修改 main.cpp 文件在 build/jsb-default/frameworks/runtime-src/proj.android/jni/hellojavascript/main.cpp 文件中添加： 1#include "PluginJniHelper.h" 1using namespace anysdk::framework; 123JavaVM* vm;env-&gt;GetJavaVM(&amp;vm);PluginJniHelper::setJavaVM(vm); 如下图 修改 AndroidManifest.xml 文件在 build/jsb-default/frameworks/runtime-src/proj.android/AndroidManifest.xml 文件中添加 AnySDK 所需要的权限： 1234567&lt;!-- for anysdk start --&gt;&lt;uses-permission android:name="android.permission.INTERNET" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt;&lt;uses-permission android:name="android.permission.RESTART_PACKAGES" /&gt;&lt;uses-permission android:name="android.permission.KILL_BACKGROUND_PROCESSES" /&gt;&lt;!-- for anysdk end --&gt; 如下图 修改 AppActivity.java 文件在 build/jsb-default/frameworks/runtime-src/proj.android/src/org/cocos2dx/javascript/AppActivity.java 添加： 123import com.anysdk.framework.PluginWrapper;import android.content.Intent; import android.os.Bundle; 1PluginWrapper.init(this); // for plugins 1234567891011121314151617181920212223242526272829303132333435363738394041@Overrideprotected void onDestroy() &#123; PluginWrapper.onDestroy(); super.onDestroy();&#125;@Overrideprotected void onPause() &#123; PluginWrapper.onPause(); super.onPause();&#125;@Overrideprotected void onResume() &#123; PluginWrapper.onResume(); super.onResume();&#125;@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; PluginWrapper.onActivityResult(requestCode, resultCode, data); super.onActivityResult(requestCode, resultCode, data);&#125;@Overrideprotected void onNewIntent(Intent intent) &#123; PluginWrapper.onNewIntent(intent); super.onNewIntent(intent);&#125;@Overrideprotected void onStop() &#123; PluginWrapper.onStop(); super.onStop();&#125;@Overrideprotected void onRestart() &#123; PluginWrapper.onRestart(); super.onRestart();&#125; 如下图 在项目中使用AnySDK获取 AnySDK 参数打开 AnySDK 客户端，点击 【打包工具】【游戏列表】【添加游戏】来在 AnySDK 客户端添加游戏项目。添加成功后，就可以获取到使用 AnySDK 需要的参数：appKey、appSecret、privateKey。 在项目中添加 AnySDK 功能代码下面给出了我在使用 AnySDK 用过的相关功能代码供大家参考。AnySDK 具体用法请参考官方的客户端接入（JS）文档。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 初始化AnySDkinitAnySDK: function () &#123; cc.log("WelcomeScreen.initAnySDK()"); if (cc.sys.isMobile) &#123; //注意：这里appKey, appSecret, privateKey，要替换成自己打包工具里面的值(登录打包工具，游戏管理界面上显示的那三个参数)。 var appKey = "23BEE66E-48A1-9BF0-CF4A-4DA25FF54082"; var appSecret = "b3d0c6f406c1f7d097f2036f445589b4"; var privateKey = "FC69F26761B6C3BEDFCDA8A2D248CC45"; var oauthLoginServer = "http://oauth.anysdk.com/api/OauthLoginDemo/Login.php"; var agent = anysdk.agentManager; //init agent.init(appKey, appSecret, privateKey, oauthLoginServer); //load agent.loadAllPlugins(); // 开启统计 cc.log("analytics_plugin.startSession();"); var analytics_plugin = anysdk.agentManager.getAnalyticsPlugin(); if (analytics_plugin) &#123; analytics_plugin.startSession(); &#125; // 开启推送服务 cc.log("push_plugin.startPush();"); var push_plugin = anysdk.agentManager.getPushPlugin(); if (push_plugin) &#123; push_plugin.startPush(); &#125; &#125;&#125;,// 显示横幅广告showBannerAd: function () &#123; cc.log("WelcomeScreen.showBannerAd()"); if (cc.sys.isMobile) &#123; var ads_plugin = anysdk.agentManager.getAdsPlugin(); if (ads_plugin.isAdTypeSupported(anysdk.AdsType.AD_TYPE_BANNER)) &#123; ads_plugin.showAds(anysdk.AdsType.AD_TYPE_BANNER); &#125; &#125;&#125;,// 显示插屏广告showFullScreenAd: function () &#123; cc.log("showFullScreenAd()"); if (cc.sys.isMobile) &#123; var ads_plugin = anysdk.agentManager.getAdsPlugin(); if (ads_plugin.isAdTypeSupported(anysdk.AdsType.AD_TYPE_FULLSCREEN)) &#123; ads_plugin.showAds(anysdk.AdsType.AD_TYPE_FULLSCREEN); &#125; &#125;&#125;,// 统计事件logEvent: function () &#123; cc.log("logEvent()"); if (cc.sys.isMobile) &#123; var analytics_plugin = anysdk.agentManager.getAnalyticsPlugin(); if (analytics_plugin) &#123; analytics_plugin.logEvent("click_logevent_btn") &#125; &#125;&#125;,// 退出游戏onExitBtnClicked: function () &#123; cc.log("onExitBtnClicked()"); // 关闭统计 cc.log("analytics_plugin.stopSession();"); if (cc.sys.isMobile) &#123; var analytics_plugin = anysdk.agentManager.getAnalyticsPlugin(); if (analytics_plugin) &#123; analytics_plugin.stopSession(); &#125; // 在游戏结束或者适当的时候，调用unloadAllPlugins来卸载SDK插件 anysdk.agentManager.unloadAllPlugins(); &#125; cc.director.end();// 退出游戏&#125; 在项目中添加了 AnySDK 相关功能代码后，使用 CocosCreator 编译出 Android APK 母包。 生成渠道包在 AnySDK 客户端配置好游戏的渠道、SDK等参数，然后使用上一步骤编译出来的 Android APK 母包生成集成了 SDK 的渠道包。 在这里就不详细说明 AnySDK 客户端的使用了，详情请参考 AnySDK 的官方文档。 如何快速集成 AnySDK我在 GitHub 上面分享了一个便于在 CocosCreator 项目的 Android 平台快速集成 AnySDK 的项目：anysdk-files-for-ccc 。具体使用方法请参考该项目的 README.md 文件，这里就不详细说明了。 总结本文主要讲解了如何在 CocosCreator 项目的 Android 平台集成 AnySDK ，并提供了一个快速集成方法。ios 平台请参考 AnySDK 的官方文档自行尝试。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CocosCreator 集成 Pomelo 教程]]></title>
      <url>http://eddy.wiki/creator-pomelo.html</url>
      <content type="text"><![CDATA[本文出自 Eddy Wiki ，转载请注明出处：http://eddy.wiki/creator-pomelo.html 本文主要介绍怎么在 CocosCreator 中集成 Pomelo， 以及使用CocosCreattor + Pomelo 开发一个多人聊天应用。 使用 Pomelo 官方多人聊天 demo（下文统一称为 pomelo-chat-demo）的服务端代码作为本多人聊天应用的服务端，而本聊天应用客户端（下文统一称为 ccc-pomelo-chat-client）则是参考 pomelo-chat-demo 的web客户端使用CocosCreattor实现。 怎么运行ccc-pomelo-chat-client本人开发环境CocosCreator 1.1, Pomelo 1.2.2, MacOS 10.10.3 安装 pomelo参考 安装 pomelo wiki 安装 pomelo。 pomelo-chat-demo 源码下载与运行ccc-pomelo-chat-client 服务端使用的是 pomelo-chat-demo 的服务端，并没有另外开发，这样可以很方便的展示多人聊天应用的多端（Web, Android, desktop等）聊天通讯功能。 参考 pomelo chat 源码下载与安装 wiki 下载 pomelo-chat-demo 源码。 下载源码后，通过下列步骤来运行 pomelo-chat-demo。下文使用 yourdir 指代你本地 pomelo-chat-demo 源码的存放目录。 打开终端，启动 pomelo-chat-demo 的聊天服务器。 $ cd yourdir/chatofpomelo-websocket/game-server $ pomelo start 打开另外一个终端，启动 pomelo-chat-demo 的 web 服务器。 $ cd yourdir/chatofpomelo-websocket/web-server $ node app.js 如果启动过程中没有错误，那么我们就可以打开浏览器，输入 http://127.0.0.1:3001/index.html, 然后就可以看到聊天应用的界面了。输入一个用户名和一个房间名，就可以开始聊天了。可以多开几个客户端实例（即打开多个网页），测试 pomelo-chat-demo 是否能正常地运行。效果图如下： 那么怎么关闭 pomelo-chat-demo 的聊天服务器呢，其实很简单。打开另外一个终端 $ cd yourdir/chatofpomelo-websocket/game-server $ pomelo stop 或 pomelo kill 注意：如果不是按以上步骤关闭聊天服务器，那么当你再次启动聊天服务器的时候，就有可能因为聊天服务器未完全关闭而出现错误。出现这种情况可以直接关闭启动聊天服务器的终端（这样聊天服务器就被完全关闭了），然后重新打一个终端启动聊天服务器。 ccc-pomelo-chat-client源码下载与运行下文使用 yourdir 指代你本地 ccc-pomelo-chat-client 源码的存放目录。 从GitHub上下载 ccc-pomelo-chat-client 源码。 $ cd yourdir $ git clone https://github.com/eddy2015/ccc-pomelo-chat-client.git 使用 CocosCreator 打开 ccc-pomelo-chat-client 项目并运行预览（模拟器和浏览器都行），效果图如下： 经本人测试，该客户端在web、Android、ccc模拟器都可以正常运行，其他平台请自行尝试。服务器 ip 地址默认为 127.0.0.1，如果你是在 Android 等其他不和服务器同一台机器平台运行，请把该 ip 修改成你启动服务器的电脑 ip 地址。端口默认为 3014，这个一般不需要修改，除非你改动了服务器端的代码。输入一个用户名和一个房间名（用户名和房间名限制了只能是字母、数字、或汉字），然后点击 join 按钮登陆后就可以进行一对多或者一对一聊天了。 CocosCreator 怎么集成 pomelo集成 pomelo 步骤下载 ccc-pomelo-chat-client 源码，把源码中的 ccc-pomelo-chat-client/assets/pomelo 拷贝到你的 CocosCreator 项目 assets 目录下，这样在你的项目中即可使用 pomelo-client 相关 API 了。 API请阅读 pomelo/pomelo-client.js 源码，具体使用方法可以参考 ccc-pomelo-chat-client 源码，或者参考以下网址： pomelo 官方中文 wiki pomelo-chat-demo 源码 pomelo 客服端开发 集成后的会出现的一些警告CocosCreator 项目集成 pomelo 后，你会在 CocosCreator 编辑器中看到如下的红色错误信息： 12Simulator : mutating the [[Prototype]] of an object will cause your code to run very slowly; instead create the object with the correct initial [[Prototype]] value using Object.create at a: &quot;Buffer.prototype.__proto__ = Uint8Array.prototype&quot; (../../../../../../../Applications/CocosCreator.app/Contents/Resources/app.asar/node_modules/buffer/index.js:153) 或者在 web 上运行时，看到下列警告信息： 1mutating the [[Prototype]] of an object will cause your code to run very slowly; instead create the object with the correct initial [[Prototype]] value using Object.create 以上的警告信息并不影响 pomelo 的使用。由于本人水平有限，所以暂时没有解决该警告问题，如果各位有解决方法，请指出。 该 CocosCreator pomelo 库由来由于前一段时间对 pomelo 比较感兴趣，所有就去了解了一下。最近也一直在关注 CocosCreator，看到论坛有不少人问 CocosCreator 是否能集成pomelo。根据我个人的理解：CocosCreator 实现了 websocket 的跨平台封装；而 pomelo 也有基于 websocket 的客户端实例。因此，CocosCreator 集成 pomelo 应该不会有什么问题的。刚好端午节有空就尝试集成了一下，然后就有了这篇文章和 ccc-pomelo-chat-client。 ccc-pomelo-chat-client 中的 pomelo 库生成过程： 拷贝 chatofpomelo-websocket/web-server/public/js/lib/components/component-emitter/index.js 文件并修改文件名为 emitter.js，在 emitter.js 文件的 module.exports = Emitter; 代码后面添加 window.EventEmitter = Emitter; 代码。 拷贝 chatofpomelo-websocket/web-server/public/js/lib/components/NetEase-pomelo-protocol/lib/protocol.js 文件。 拷贝 chatofpomelo-websocket/web-server/public/js/lib/components/pomelonode-pomelo-protobuf/lib/client/protobuf.js 文件。 拷贝 chatofpomelo-websocket/web-server/public/js/lib/components/pomelonode-pomelo-jsclient-websocket/lib/pomelo-client.js 文件，并使用 cc.log、 cc.error 替换文件中的 console.log、console.error。 最后这是我博客的第一篇博文（除了 HelloWord 外^_^），希望大家喜欢。由于本人水平有限，文章中难免错漏之处，请各位不吝指正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://eddy.wiki/hello-world.html</url>
      <content type="text"><![CDATA[欢迎来到本博客！本博客永久地址为：http://eddy.wiki]]></content>
    </entry>

    
  
  
</search>
